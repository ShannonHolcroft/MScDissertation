---
title: "Outcome Selection (Full): Group A and B"
author: "Shannon Holcroft"
format: html
---

Both time and the variables of interest are reference coded. The time effect describes the average change over time for the reference group (or if two patients were compared, holding the variable of interest constant). The variable of interest effect is then expressed as deviations from the trajectory of the reference group. 

Looking at time-variable interactions gives you the level differences in within-level changes (i.e. the level effect) from baseline to each time point, expressing these differences as deviations from the general time effect.

```{r}
library(tidyverse)
library(reshape2)
library(factoextra)
library(ggpubr)
library(cluster)
library(ggdendro)
library(glmmTMB)
library(readxl)
library(emmeans)

```

## Read in modelling data

```{r}
# Read in group data

groupA = read_xlsx("groupAinfantsData_AD_23Feb2023.xlsx")
varA = colnames(groupA[, 17:56])

groupB = read_xlsx("groupBinfantsData_AD_23Feb2023.xlsx")
varB = colnames(groupB[, 16:34])

# Change variable names

## Study design and covariates

colnames(groupA)[1:4] = c("ID", "Group", "Time", "Treatment")
groupA$Time = as.factor(groupA$Time)
colnames(groupA)[10] = c("QFT")
colnames(groupA)[12:13] = c("Feeding", "Antibiotic")

colnames(groupB)[1:4] =  c("ID", "Group", "Time", "Treatment")
groupB$Time = as.factor(groupB$Time)
colnames(groupB)[10] = c("QFT")
colnames(groupB)[12:13] = c("Feeding", "Antibiotic")

# Create new dummy variables for feeding and antibiotic

groupA$FA = ifelse(groupA$Feeding == "Breast Milk" & groupA$Antibiotic == "Yes", 3, ifelse(groupA$Feeding == "Breast Milk" & groupA$Antibiotic == "No", 2, ifelse(groupA$Feeding == "Formula" & groupA$Antibiotic == "No", 1, 0)))
groupA$FA = factor(groupA$FA)

groupB$FA = ifelse(groupB$Feeding == "Breast Milk" & groupB$Antibiotic == "Y", 3, ifelse(groupB$Feeding == "Breast Milk" & groupB$Antibiotic == "N", 2, ifelse(groupB$Feeding == "Formula" & groupB$Antibiotic == "N", 1, 0)))
groupB$FA = factor(groupB$FA)

## Create immune response data sets

# Rename by number

groupA = rename_with(.data = groupA, .fn = ~ paste0("O", 1:length(varA)), .cols = 17:56)
groupB = rename_with(.data = groupB, .fn = ~ paste0("O", 1:length(varB)), .cols = 16:34)

# Drop indeterminate QFT observations
indet_idsA = groupA[which(groupA$QFT == "Indeterminate"), ]$ID
indet_idsB = groupB[which(groupB$QFT == "Indeterminate"), ]$ID

groupA = groupA[-which(groupA$ID %in% indet_idsA), ]
groupB = groupB[-which(groupB$ID %in% indet_idsB), ]

# Make time and variables of interest factors

colnam = c("Treatment", "Time", "Gender", "QFT", "FA")
groupA[colnam] = lapply(groupA[colnam], factor)
groupB[colnam] = lapply(groupB[colnam], factor)

# Set reference levels for Group A

groupA$Time = factor(groupA$Time, levels = c("112", "56", "365"))

# Divide Group B by time points and set reference levels

groupB1 = groupB[, -c(16:18, 23:34)]
groupB1 = groupB1[-which(groupB1$Time %in% c("63", "0", "56")), ]
groupB1$Time = factor(groupB1$Time, levels = c("112", "365"))

groupB2 = groupB[, -c(16:22)]
groupB2 = groupB2[-which(groupB2$Time %in% c("112", "0", "365")), ]
groupB2$Time = factor(groupB2$Time, levels = c("63", "56"))

# Relevel for coefficient extraction

groupAre1 = groupA
groupAre1$FA = factor(groupAre1$FA, levels = c(3, 0, 1, 2))
groupAre1[colnam] = lapply(groupAre1[colnam], factor)

groupB1re1 = groupB1
groupB1re1$FA = factor(groupB1re1$FA, levels = c(3, 0, 1, 2))
groupB1re1[colnam] = lapply(groupB1re1[colnam], factor)

groupB2re1 = groupB2
groupB2re1$FA = factor(groupB2re1$FA, levels = c(3, 0, 1, 2))
groupB2re1[colnam] = lapply(groupB2re1[colnam], factor)

```


## Data Preparation

Read in the data extracted from the fitted GLMMs for each group and variable of interest.

```{r, echo=FALSE}

# Read in combined data

alldat = read.csv("combined_data.csv")[-1]

# Drop very infrequently observed immune outcomes, antibody titres and assays

droplist = c("%CD8+ totIL17+", "%CD8+ totIL2+", "%CD8+ totIL22+", "Baby Anti-BCG IgA (AUC)", "Baby Anti-BCG IgM (AUC)", "Baby Anti-BCG IgG (AUC)", "Elispot (BCG)")

alldat = alldat[-which(alldat$Outcome %in% droplist), ]

# Change names for display for certain immune outcomes

namelist = c("bulk CD8+/% R7-RA-", "bulk CD8+/% R7-RA+", "bulk CD8+/% R7+RA-", "bulk CD8+/% R7+RA+", "CD8+ ANYcytok+")
namechange = c("Bulk CD8+/% R7-RA-", "Bulk CD8+/% R7-RA+", "Bulk CD8+/% R7+RA-", "Bulk CD8+/% R7+RA+", "%CD8+ ANYcytok+")

alldat = alldat %>% mutate(Outcome = if_else(Outcome %in% namelist, recode(Outcome, !!!setNames(namechange, namelist)), Outcome))

# Separate into Group A and Group B

datA = alldat %>% filter(Arm == "A")
allA = unique(datA$Outcome)

datB = alldat %>% filter(Arm == "B")
allB = unique(datB$Outcome)

# Separate by variables of interest

dat1A = datA %>% filter(Group == "MVA85A") %>% filter(Coefficient %in% c("TreatmentMVA85A", "TreatmentMVA85A:Time56", "TreatmentMVA85A:Time365"))
dat1B = datB %>% filter(Group == "MVA85A") %>% filter(Coefficient %in% c("TreatmentMVA85A", "TreatmentMVA85A:Time56", "TreatmentMVA85A:Time365"))

dat2A = datA %>% filter(Group == "QFT") %>% filter(Coefficient %in% c("QFTPositive", "QFTPositive:Time56", "QFTPositive:Time365"))
dat2B = datB %>% filter(Group == "QFT") %>% filter(Coefficient %in% c("QFTPositive", "QFTPositive:Time56", "QFTPositive:Time365"))

dat3A = datA %>% filter(Group %in% c("FA - FA", "FA - BA"))

# Retain specific comparisons of interest: FA0 in FA-BA, FA1 in FA-FA, FA2 in FA-FA, FA3 in FA-BA

dat3.1.1A = dat3A %>% filter(Group == "FA - FA") %>% filter(Coefficient %in% c("FA1", "FA3", "FA1:Time56", "FA1:Time365", "FA3:Time56", "FA3:Time365", "FA1:Time63", "FA3:Time63"))
dat3.1.2A = dat3A %>% filter(Group == "FA - BA") %>% filter(Coefficient %in% c("FA0", "FA2", "FA0:Time56", "FA2:Time56", "FA2:Time365",  "FA0:Time365", "FA0:Time63","FA2:Time63"))
      
dat3A = rbind(dat3.1.1A, dat3.1.2A)

dat3B = datB %>% filter(Group %in% c("FA - FA", "FA - BA"))

# Retain specific comparisons of interest: FA0 in FA-BA, FA1 in FA-FA, FA2 in FA-FA, FA3 in FA-BA

dat3.1.1B = dat3B %>% filter(Group == "FA - FA") %>% filter(Coefficient %in% c("FA1", "FA3", "FA1:Time56", "FA1:Time365", "FA3:Time56", "FA3:Time365", "FA1:Time63", "FA3:Time63"))
dat3.1.2B = dat3B %>% filter(Group == "FA - BA") %>% filter(Coefficient %in% c("FA0", "FA2", "FA0:Time56", "FA2:Time56", "FA2:Time365",  "FA0:Time365", "FA0:Time63","FA2:Time63"))
      
dat3B = rbind(dat3.1.1B, dat3.1.2B)

dat4A = datA %>% filter(Coefficient %in% c("GenderM", "Time56:GenderM", "Time365:GenderM"))
dat4B = datB %>% filter(Coefficient %in% c("GenderM", "Time56:GenderM", "Time365:GenderM"))
```

Create data frames for PCA

```{r}
# Create long format data frames for groups A and B

tmelt_1A = melt(dat1A) %>% filter(variable == "EstOverSE")
tmelt_2A = melt(dat2A) %>% filter(variable == "EstOverSE")
tmelt_3A = melt(dat3A) %>% filter(variable == "EstOverSE")
tmelt_4A = melt(dat4A) %>% filter(variable == "EstOverSE")

tmelt_1B = melt(dat1B) %>% filter(variable == "EstOverSE")
tmelt_2B = melt(dat2B) %>% filter(variable == "EstOverSE")
tmelt_3B = melt(dat3B) %>% filter(variable == "EstOverSE")
tmelt_4B = melt(dat4B) %>% filter(variable == "EstOverSE")

```

## Make some heat maps to visualize what we're putting into the PCA

```{r}

ggplot(tmelt_1A, aes(x = Coefficient, y = reorder(Outcome, value), fill = value)) +
  geom_tile(color = "black") +
  theme(axis.text.y = element_text(size=5), axis.text.x = element_text(size=7, angle = 90), axis.title.y = element_blank(), axis.title.x = element_blank(), legend.title = element_blank()) +
  scale_fill_gradient2(low = "#075AFF",
                       mid = "white",
                       high = "#FF0000") + coord_fixed()

ggplot(tmelt_2A, aes(x = Coefficient, y = reorder(Outcome, value), fill = value)) +
  geom_tile(color = "black") +
  theme(axis.text.y = element_text(size=5), axis.text.x = element_text(size=7, angle = 90), axis.title.y = element_blank(), axis.title.x = element_blank(), legend.title = element_blank()) +
  scale_fill_gradient2(low = "#075AFF",
                       mid = "white",
                       high = "#FF0000") + coord_fixed()

ggplot(tmelt_3A, aes(x = Coefficient, y = reorder(Outcome, value), fill = value)) +
  geom_tile(color = "black") +
  theme(axis.text.y = element_text(size=5), axis.text.x = element_text(size=7, angle = 90), axis.title.y = element_blank(), axis.title.x = element_blank(), legend.title = element_blank()) +
  scale_fill_gradient2(low = "#075AFF",
                       mid = "white",
                       high = "#FF0000") + coord_fixed()

ggplot(tmelt_4A, aes(x = Coefficient, y = reorder(Outcome, value), fill = value)) +
  geom_tile(color = "black") +
  theme(axis.text.y = element_text(size=5), axis.text.x = element_text(size=7, angle = 90), axis.title.y = element_blank(), axis.title.x = element_blank(), legend.title = element_blank()) +
  scale_fill_gradient2(low = "#075AFF",
                       mid = "white",
                       high = "#FF0000") + coord_fixed()

ggplot(tmelt_1B, aes(x = Coefficient, y = reorder(Outcome, value), fill = value)) +
  geom_tile(color = "black") +
  theme(axis.text.y = element_text(size=5), axis.text.x = element_text(size=7, angle = 90), axis.title.y = element_blank(), axis.title.x = element_blank(), legend.title = element_blank()) +
  scale_fill_gradient2(low = "#075AFF",
                       mid = "white",
                       high = "#FF0000") + coord_fixed()

ggplot(tmelt_2B, aes(x = Coefficient, y = reorder(Outcome, value), fill = value)) +
  geom_tile(color = "black") +
  theme(axis.text.y = element_text(size=5), axis.text.x = element_text(size=7, angle = 90), axis.title.y = element_blank(), axis.title.x = element_blank(), legend.title = element_blank()) +
  scale_fill_gradient2(low = "#075AFF",
                       mid = "white",
                       high = "#FF0000") + coord_fixed()

ggplot(tmelt_3B, aes(x = Coefficient, y = reorder(Outcome, value), fill = value)) +
  geom_tile(color = "black") +
  theme(axis.text.y = element_text(size=5), axis.text.x = element_text(size=7, angle = 90), axis.title.y = element_blank(), axis.title.x = element_blank(), legend.title = element_blank()) +
  scale_fill_gradient2(low = "#075AFF",
                       mid = "white",
                       high = "#FF0000") + coord_fixed()

ggplot(tmelt_4B, aes(x = Coefficient, y = reorder(Outcome, value), fill = value)) +
  geom_tile(color = "black") +
  theme(axis.text.y = element_text(size=5), axis.text.x = element_text(size=7, angle = 90), axis.title.y = element_blank(), axis.title.x = element_blank(), legend.title = element_blank()) +
  scale_fill_gradient2(low = "#075AFF",
                       mid = "white",
                       high = "#FF0000") + coord_fixed()
```

## Principal Component Analysis

## MVA85A

Apply PCA to standardised regression coefficients for MVA85A and interactions between MVA85A and time points. In Group A, the first PCs explains sufficient variance in the standardised regression coefficients. 

```{r}

pca1.2A = tmelt_1A[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

pca1.2A = pca1.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca1.2A_wide = pca1.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca1.2A_mat = as.matrix(pca1.2A_wide[, 2:4], nrow = nrow(pca1.2A_wide), ncol = 3)
rownames(pca1.2A_mat) = pca1.2A_wide$Outcome
str(pca1.2A_mat)

pca1.2Ares = princomp(pca1.2A_mat, cor = TRUE, scores = TRUE)
summary(pca1.2Ares) # Component 1 should suffice

fviz_eig(pca1.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))


```

PC1 primarily describes Day 56 with Day 112 as the reference point and MVA85A priming at Day 365. 
```{r}
fviz_contrib(pca1.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

9 immune outcomes score more highly than the uniform expectation on PC1. 
```{r}
fviz_contrib(pca1.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

They are selected to a subset.

```{r}
contrib1.2A.1 = fviz_contrib(pca1.2Ares, axes = 1, choice = "ind")

pc1dat = contrib1.2A.1$data[which(contrib1.2A.1$data$contrib >= 3), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

mva_pca_set = pcnames1

```

## QFT

Apply PCA to standardised regression coefficients for QFT+ and interactions between QFT+ and time points. In Group A, 1 PC is sufficient.

```{r}

pca2.2A = tmelt_2A[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

pca2.2A = pca2.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca2.2A_wide = pca2.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca2.2A_mat = as.matrix(pca2.2A_wide[, 2:4], nrow = nrow(pca2.2A_wide), ncol = 3)
rownames(pca2.2A_mat) = pca2.2A_wide$Outcome
str(pca2.2A_mat)

pca2.2Ares = princomp(pca2.2A_mat, cor = TRUE, scores = TRUE)
summary(pca2.2Ares) # Component 1 should suffice

fviz_eig(pca2.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```

PC1 primarily describes QFT 8 weeks after BCG.

```{r}

fviz_contrib(pca2.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))


```
There are 11 contributing immune outcomes.

```{r}
fviz_contrib(pca2.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 15) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```

```{r}
contrib2.2A.1 = fviz_contrib(pca2.2Ares, axes = 1, choice = "ind")

pc1dat = contrib2.2A.1$data[which(contrib2.2A.1$data$contrib >= 3), ]

pcnames1 = as.character(unique(c(pc1dat$name)))
#pcnames2 = as.character(unique(c(pc1dat$name)))

qft_pca_set = pcnames1

```

Perform PCA on FA coefficients. Two PCs should be analysed.

```{r}
mat3.2A = tmelt_3A[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

pca3.2A = mat3.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca3.2A_wide = pca3.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca3.2A_mat = as.matrix(pca3.2A_wide[, 2:9], nrow = nrow(pca3.2A_wide), ncol = 8)
rownames(pca3.2A_mat) = pca3.2A_wide$Outcome

pca3.2Ares = princomp(pca3.2A_mat, cor = TRUE, scores = TRUE)
summary(pca3.2Ares) # Component 1 should suffice

fviz_eig(pca3.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))
```

PC1 primarily describes FA3. PC2 primarily described FA1.

```{r}

fviz_contrib(pca3.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca3.2Ares, axes = 2, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))


```

PC1 has 8 contributing outcomes. PC2 has 11 contributing outcomes.

```{r}

fviz_contrib(pca3.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 15) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca3.2Ares, axes = 2, choice = "ind", fill = "darkgrey", color = "black", top = 15) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```

The combined set contains 15 immune outcomes.

```{r}
contrib3.2A.1 = fviz_contrib(pca3.2Ares, axes = 1, choice = "ind")
contrib3.2A.2 = fviz_contrib(pca3.2Ares, axes = 2, choice = "ind")

pc1dat = contrib3.2A.1$data[which(contrib3.2A.1$data$contrib >= 3), ]
pc2dat = contrib3.2A.2$data[which(contrib3.2A.2$data$contrib >= 3), ]

pcnames1 = as.character(unique(c(pc1dat$name, pc2dat$name)))

fa_pca_set = pcnames1

```

Assuming that the subsets are independent, we can perform corrections within subsets. Retrieve the fitted models by VOI.

```{r}
# MVA85A 

AM_1.1 = glmmTMB(O4 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_1.1 = summary(AM_1.1)

AM_1.2 =glmmTMB(O17 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_1.2 = summary(AM_1.2)

AM_1.3 =glmmTMB(O20 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_1.3 = summary(AM_1.3)

AM_1.4 = glmmTMB(O31 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = poisson(link = "log"))
AS_1.4 = summary(AM_1.4)

AM_1.5 = glmmTMB(O27 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_1.5 = summary(AM_1.5)

AM_1.6 = glmmTMB(O25 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_1.6 = summary(AM_1.6)

AM_1.7 = glmmTMB(94-O15 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_1.7 = summary(AM_1.7)

AM_1.8 = glmmTMB(101 - O19 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_1.8 = summary(AM_1.8)

AM_1.9 = glmmTMB(101 - O36 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_1.9 = summary(AM_1.9)

n1 = length(mva_pca_set)
v1.1 = varA[4]
v1.2 = varA[17]
v1.3 = varA[20]
v1.4 = varA[31]
v1.5 = varA[27]
v1.6 = varA[25]
v1.7 = varA[15]
v1.8 = varA[19]
v1.9 = varA[36]

```

Create a contrast matrix for the predetermined pairwise comparisons.

```{r}

# Extract combinations of the levels

combinations = data.frame(emmeans(AM_1.1, ~ Treatment * Time))
combination_names = paste(combinations$Treatment, combinations$Time, sep = "_")

# Define the list of contrasts

contrast_list = list(
  
  # Comparisons within Control
  
  "Control_T2_vs_T1" = setNames(c(1, 0, -1, 0, 0, 0), combination_names),
  "Control_T2_vs_T3" = setNames(c(1, 0, 0, 0, -1, 0), combination_names),
  "Control_T1_vs_T3" = setNames(c(0, 0, 1, 0, -1, 0), combination_names),
  
  # Comparisons within MVA85A
  
  "MVA85A_T2_vs_T1" = setNames(c(0, 1, 0, -1, 0, 0), combination_names),
  "MVA85A_T2_vs_T3" = setNames(c(0, 1, 0, 0, 0, -1), combination_names),
  "MVA85A_T1_vs_T3" = setNames(c(0, 0, 0, 1, 0, -1), combination_names),
  
  # Comparisons between Control and MVA85A
  
  "T2_Control_vs_MVA85A" = setNames(c(1, -1, 0, 0, 0, 0), combination_names),
  "T1_Control_vs_MVA85A" = setNames(c(0, 0, 1, -1, 0, 0), combination_names),
  "T3_Control_vs_MVA85A" = setNames(c(0, 0, 0, 0, 1, -1), combination_names)
)

contrast_list
```

Estimate and apply corrections for MVA85A priming. Only significant differences within group over time.
```{r}

emm1.1 = emmeans(AM_1.1, ~ Treatment * Time)
emm1.2 = emmeans(AM_1.2, ~ Treatment * Time)
emm1.3 = emmeans(AM_1.3, ~ Treatment * Time)
emm1.4 = emmeans(AM_1.4, ~ Treatment * Time)
emm1.5 = emmeans(AM_1.5, ~ Treatment * Time)
emm1.6 = emmeans(AM_1.6, ~ Treatment * Time)
emm1.7 = emmeans(AM_1.7, ~ Treatment * Time)
emm1.8 = emmeans(AM_1.8, ~ Treatment * Time)
emm1.9 = emmeans(AM_1.9, ~ Treatment * Time)

# Apply custom contrasts
contrasts1.1 = data.frame(contrast(emm1.1, method = contrast_list, adjust = "none"))
contrasts1.2 = data.frame(contrast(emm1.2, method = contrast_list, adjust = "none"))
contrasts1.3 = data.frame(contrast(emm1.3, method = contrast_list, adjust = "none"))
contrasts1.4 = data.frame(contrast(emm1.4, method = contrast_list, adjust = "none"))
contrasts1.5 = data.frame(contrast(emm1.5, method = contrast_list, adjust = "none"))
contrasts1.6 = data.frame(contrast(emm1.6, method = contrast_list, adjust = "none"))
contrasts1.7 = data.frame(contrast(emm1.7, method = contrast_list, adjust = "none"))
contrasts1.8 = data.frame(contrast(emm1.8, method = contrast_list, adjust = "none"))
contrasts1.9 = data.frame(contrast(emm1.9, method = contrast_list, adjust = "none"))

contrasts1.1$Outcome = v1.1
contrasts1.2$Outcome = v1.2
contrasts1.3$Outcome = v1.3
contrasts1.4$Outcome = v1.4
contrasts1.5$Outcome = v1.5
contrasts1.6$Outcome = v1.6
contrasts1.7$Outcome = v1.7
contrasts1.8$Outcome = v1.8
contrasts1.9$Outcome = v1.9

mvapcares = rbind(contrasts1.1, contrasts1.2, contrasts1.3, contrasts1.4,
                  contrasts1.5, contrasts1.6, contrasts1.7, contrasts1.8, contrasts1.9)
mvapcares = mvapcares %>% arrange(p.value)

mvapcares$BH = p.adjust(mvapcares$p.value, method = "BH", n = length(mvapcares$p.value))
mvapcares$BY = p.adjust(mvapcares$p.value, method = "BY", n = length(mvapcares$p.value))

mvapcares$expestimate = exp(mvapcares$estimate)

mvapcares %>% filter(BH < 0.06) %>% filter(Outcome == v1.1)

mvapcares %>% filter(BH < 0.06) %>% filter(Outcome == v1.2)

mvapcares %>% filter(BH < 0.06) %>% filter(Outcome == v1.3)

mvapcares %>% filter(BH < 0.06) %>% filter(Outcome == v1.4)

mvapcares %>% filter(BH < 0.06) %>% filter(Outcome == v1.5)

mvapcares %>% filter(BH < 0.06) %>% filter(Outcome == v1.6)

mvapcares %>% filter(BH < 0.06) %>% filter(Outcome == v1.7)

mvapcares %>% filter(BH < 0.06) %>% filter(Outcome == v1.8)

mvapcares %>% filter(BH < 0.06) %>% filter(Outcome == v1.9)

```

```{r}
# QFT

qft_pca_set

AM_2.1 = glmmTMB(O13 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_2.1 = summary(AM_2.1)

AM_2.2 = glmmTMB(O16 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_2.2 = summary(AM_2.2)

AM_2.3 = glmmTMB(O21 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_2.3 = summary(AM_2.3)

AM_2.4 = glmmTMB(O18 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_2.4 = summary(AM_2.4)

AM_2.5 = glmmTMB(O22 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_2.5 = summary(AM_2.5)

AM_2.6 = glmmTMB(O23 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_2.6 = summary(AM_2.6)

AM_2.7 = glmmTMB(O24 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_2.7 = summary(AM_2.7)

AM_2.8 = glmmTMB(O31 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_2.8 = summary(AM_2.8)

AM_2.9 = glmmTMB(O25 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_2.9 = summary(AM_2.9)

AM_2.10 = glmmTMB(O30 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_2.10 = summary(AM_2.10)

AM_2.11 = glmmTMB(101 - O36 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_2.11 = summary(AM_2.11)

n2 = length(qft_pca_set)

v2.1 = varA[13]
v2.2 = varA[16]
v2.3 = varA[21]
v2.4 = varA[18]
v2.5 = varA[22]
v2.6 = varA[23]
v2.7 = varA[24]
v2.8 = varA[31]
v2.9 = varA[25]
v2.10 = varA[30]
v2.11 = varA[36]

```

Create a contrast matrix for the predetermined pairwise comparisons.

```{r}

# Extract combinations of the levels

combinations = data.frame(emmeans(AM_2.1, ~ QFT * Time))
combination_names = paste(combinations$QFT, combinations$Time, sep = "_")

# Define the list of contrasts

contrast_list = list(
  
  # Comparisons within Negative
  
  "Negative_T2_vs_T1" = setNames(c(1, 0, -1, 0, 0, 0), combination_names),
  "Negative_T2_vs_T3" = setNames(c(1, 0, 0, 0, -1, 0), combination_names),
  "Negative_T1_vs_T3" = setNames(c(0, 0, 1, 0, -1, 0), combination_names),
  
  # Comparisons within Positive
  
  "Positive_T2_vs_T1" = setNames(c(0, 1, 0, -1, 0, 0), combination_names),
  "Positive_T2_vs_T3" = setNames(c(0, 1, 0, 0, 0, -1), combination_names),
  "Positive_T1_vs_T3" = setNames(c(0, 0, 0, 1, 0, -1), combination_names),
  
  # Comparisons between Negative and Positive
  
  "T2_Negative_vs_Positive" = setNames(c(1, -1, 0, 0, 0, 0), combination_names),
  "T1_Negative_vs_Positive" = setNames(c(0, 0, 1, -1, 0, 0), combination_names),
  "T3_Negative_vs_Positive" = setNames(c(0, 0, 0, 0, 1, -1), combination_names)
)

contrast_list
```

Estimate and apply corrections for QFT. Only significant differences within group over time.
```{r}

emm2.1 = emmeans(AM_2.1, ~ QFT * Time)
emm2.2 = emmeans(AM_2.2, ~ QFT * Time)
emm2.3 = emmeans(AM_2.3, ~ QFT * Time)
emm2.4 = emmeans(AM_2.4, ~ QFT * Time)
emm2.5 = emmeans(AM_2.5, ~ QFT * Time)
emm2.6 = emmeans(AM_2.6, ~ QFT * Time)
emm2.7 = emmeans(AM_2.7, ~ QFT * Time)
emm2.8 = emmeans(AM_2.8, ~ QFT * Time)
emm2.9 = emmeans(AM_2.9, ~ QFT * Time)
emm2.10 = emmeans(AM_2.10, ~ QFT * Time)
emm2.11 = emmeans(AM_2.11, ~ QFT * Time)

# Apply custom contrasts
contrasts1.1 = data.frame(contrast(emm2.1, method = contrast_list, adjust = "none"))
contrasts1.2 = data.frame(contrast(emm2.2, method = contrast_list, adjust = "none"))
contrasts1.3 = data.frame(contrast(emm2.3, method = contrast_list, adjust = "none"))
contrasts1.4 = data.frame(contrast(emm2.4, method = contrast_list, adjust = "none"))
contrasts1.5 = data.frame(contrast(emm2.5, method = contrast_list, adjust = "none"))
contrasts1.6 = data.frame(contrast(emm2.6, method = contrast_list, adjust = "none"))
contrasts1.7 = data.frame(contrast(emm2.7, method = contrast_list, adjust = "none"))
contrasts1.8 = data.frame(contrast(emm2.8, method = contrast_list, adjust = "none"))
contrasts1.9 = data.frame(contrast(emm2.9, method = contrast_list, adjust = "none"))
contrasts1.10 = data.frame(contrast(emm2.10, method = contrast_list, adjust = "none"))
contrasts1.11 = data.frame(contrast(emm2.11, method = contrast_list, adjust = "none"))

contrasts1.1$Outcome = v2.1
contrasts1.2$Outcome = v2.2
contrasts1.3$Outcome = v2.3
contrasts1.4$Outcome = v2.4
contrasts1.5$Outcome = v2.5
contrasts1.6$Outcome = v2.6
contrasts1.7$Outcome = v2.7
contrasts1.8$Outcome = v2.8
contrasts1.9$Outcome = v2.9
contrasts1.10$Outcome = v2.10
contrasts1.11$Outcome = v2.11

qftpcares = rbind(contrasts1.1, contrasts1.2, contrasts1.3, contrasts1.4,
                  contrasts1.5, contrasts1.6, contrasts1.7, contrasts1.8, contrasts1.9,
                  contrasts1.10, contrasts1.11)
qftpcares = qftpcares %>% arrange(p.value)

qftpcares$BH = p.adjust(qftpcares$p.value, method = "BH", n = length(qftpcares$p.value))
qftpcares$BY = p.adjust(qftpcares$p.value, method = "BY", n = length(qftpcares$p.value))

qftpcares$expestimate = exp(qftpcares$estimate)

qftpcares %>% filter(BH < 0.06) %>% filter(Outcome == v2.1)

qftpcares %>% filter(BH < 0.06) %>% filter(Outcome == v2.2)

qftpcares %>% filter(BH < 0.06) %>% filter(Outcome == v2.3)

qftpcares %>% filter(BH < 0.06) %>% filter(Outcome == v2.4)

qftpcares %>% filter(BH < 0.06) %>% filter(Outcome == v2.5)

qftpcares %>% filter(BH < 0.06) %>% filter(Outcome == v2.6)

qftpcares %>% filter(BH < 0.06) %>% filter(Outcome == v2.7)

qftpcares %>% filter(BH < 0.06) %>% filter(Outcome == v2.8)

qftpcares %>% filter(BH < 0.06) %>% filter(Outcome == v2.9)

qftpcares %>% filter(BH < 0.06) %>% filter(Outcome == v2.10)

qftpcares %>% filter(BH < 0.06) %>% filter(Outcome == v2.11)

```

```{r}
# FA

AM_3.1 = glmmTMB(O17 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_3.1 = summary(AM_3.1)

AM_3.2 = glmmTMB(O21 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_3.2 = summary(AM_3.2)

AM_3.3 = glmmTMB(O18 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_3.3 = summary(AM_3.3)

AM_3.4 = glmmTMB(O39 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_3.4 = summary(AM_3.4)

AM_3.5 = glmmTMB(O25 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_3.5 = summary(AM_3.5)

AM_3.6 = glmmTMB(94-O15 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_3.6 = summary(AM_3.6)

AM_3.7 = glmmTMB(101 - O19 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_3.7 = summary(AM_3.7)

AM_3.8 = glmmTMB(101 - O36 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_3.8 = summary(AM_3.8)

AM_3.9 = glmmTMB(O9 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_3.9 = summary(AM_3.9)

AM_3.10 = glmmTMB(O13 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_3.10 = summary(AM_3.10)

AM_3.11 = glmmTMB(O16 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_3.11 = summary(AM_3.11)

AM_3.12 = glmmTMB(O20 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_3.12 = summary(AM_3.12)

AM_3.13 = glmmTMB(O23 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_3.13 = summary(AM_3.13)

AM_3.14 = glmmTMB(O31 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_3.14 = summary(AM_3.14)

AM_3.15 = glmmTMB(O27 ~ FA*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_3.15 = summary(AM_3.15)

n3 = length(fa_pca_set)

v3.1 = varA[17]
v3.2 = varA[21]
v3.3 = varA[18]
v3.4 = varA[39]
v3.5 = varA[25]
v3.6 = varA[15]
v3.7 = varA[19]
v3.8 = varA[36]
v3.9 = varA[9]
v3.10 = varA[13]
v3.11 = varA[16]
v3.12 = varA[20]
v3.13 = varA[23]
v3.14 = varA[31]
v3.15 = varA[27]

```

Create a contrast matrix for the predetermined pairwise comparisons in Group A.

```{r}

# Extract combinations of the levels

combinations = data.frame(emmeans(AM_3.1, ~ FA * Time))
combination_names = paste(combinations$FA, combinations$Time, sep = "_")

# Define the list of contrasts

length(combination_names)

contrast_list = list(
  
  # Comparisons within FA0
  
  "FA0_T2_vs_T1" = setNames(c(1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0), combination_names),
  "FA0_T2_vs_T3" = setNames(c(1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0, 0), combination_names),
  "FA0_T1_vs_T3" = setNames(c(0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0), combination_names),
  
  # Comparisons within FA1
  
  "FA1_T2_vs_T1" = setNames(c(0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0, 0), combination_names),
  "FA1_T2_vs_T3" = setNames(c(0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0, 0), combination_names),
  "FA1_T1_vs_T3" = setNames(c(0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0, 0), combination_names),
  
  # Comparisons within FA2
  
  "FA2_T2_vs_T1" = setNames(c(0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0, 0), combination_names),
  "FA2_T2_vs_T3" = setNames(c(0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0), combination_names),
  "FA2_T1_vs_T3" = setNames(c(0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1, 0), combination_names),
  
  # Comparisons within FA3
  
  "FA3_T2_vs_T1" = setNames(c(0, 0, 0, 1, 0, 0, 0, -1, 0, 0, 0, 0), combination_names),
  "FA3_T2_vs_T3" = setNames(c(0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, -1), combination_names),
  "FA3_T1_vs_T3" = setNames(c(0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, -1), combination_names),
  
  
  # Comparisons between FA0 and FA3
  
  "T2_FA0_vs_FA3" = setNames(c(1, 0, 0, -1, 0, 0, 0, 0, 0, 0, 0, 0), combination_names),
  "T1_FA0_vs_FA3" = setNames(c(0, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 0), combination_names),
  "T3_FA0_VS_FA3" = setNames(c(0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, -1), combination_names),
  
  # Comparisons between FA0 and FA1
  
  "T2_FA0_vs_FA1" = setNames(c(1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0), combination_names),
  "T1_FA0_vs_FA1" = setNames(c(0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0), combination_names),
  "T3_FA0_VS_FA1" = setNames(c(0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0), combination_names),
  
  
  # Comparisons between FA2 and FA3
  
  "T2_FA2_vs_FA3" = setNames(c(0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0), combination_names),
  "T1_FA2_vs_FA3" = setNames(c(0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0), combination_names),
  "T3_FA2_VS_FA3" = setNames(c(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1), combination_names)
  
  
)

contrast_list
```

Estimate and apply corrections for FA. Only significant differences within group over time.
```{r}

emm3.1 = emmeans(AM_3.1, ~ FA * Time)
emm3.2 = emmeans(AM_3.2, ~ FA * Time)
emm3.3 = emmeans(AM_3.3, ~ FA * Time)
emm3.4 = emmeans(AM_3.4, ~ FA * Time)
emm3.5 = emmeans(AM_3.5, ~ FA * Time)
emm3.6 = emmeans(AM_3.6, ~ FA * Time)
emm3.7 = emmeans(AM_3.7, ~ FA * Time)
emm3.8 = emmeans(AM_3.8, ~ FA * Time)
emm3.9 = emmeans(AM_3.9, ~ FA * Time)
emm3.10 = emmeans(AM_3.10, ~ FA * Time)
emm3.11 = emmeans(AM_3.11, ~ FA * Time)
emm3.12 = emmeans(AM_3.12, ~ FA * Time)
emm3.13 = emmeans(AM_3.13, ~ FA * Time)
emm3.14 = emmeans(AM_3.14, ~ FA * Time)
emm3.15 = emmeans(AM_3.15, ~ FA * Time)

# Apply custom contrasts
contrasts1.1 = data.frame(contrast(emm3.1, method = contrast_list, adjust = "none"))
contrasts1.2 = data.frame(contrast(emm3.2, method = contrast_list, adjust = "none"))
contrasts1.3 = data.frame(contrast(emm3.3, method = contrast_list, adjust = "none"))
contrasts1.4 = data.frame(contrast(emm3.4, method = contrast_list, adjust = "none"))
contrasts1.5 = data.frame(contrast(emm3.5, method = contrast_list, adjust = "none"))
contrasts1.6 = data.frame(contrast(emm3.6, method = contrast_list, adjust = "none"))
contrasts1.7 = data.frame(contrast(emm3.7, method = contrast_list, adjust = "none"))
contrasts1.8 = data.frame(contrast(emm3.8, method = contrast_list, adjust = "none"))
contrasts1.9 = data.frame(contrast(emm3.9, method = contrast_list, adjust = "none"))
contrasts1.10 = data.frame(contrast(emm3.10, method = contrast_list, adjust = "none"))
contrasts1.11 = data.frame(contrast(emm3.11, method = contrast_list, adjust = "none"))
contrasts1.12 = data.frame(contrast(emm3.12, method = contrast_list, adjust = "none"))
contrasts1.13 = data.frame(contrast(emm3.13, method = contrast_list, adjust = "none"))
contrasts1.14 = data.frame(contrast(emm3.14, method = contrast_list, adjust = "none"))
contrasts1.15 = data.frame(contrast(emm3.15, method = contrast_list, adjust = "none"))

contrasts1.1$Outcome = v3.1
contrasts1.2$Outcome = v3.2
contrasts1.3$Outcome = v3.3
contrasts1.4$Outcome = v3.4
contrasts1.5$Outcome = v3.5
contrasts1.6$Outcome = v3.6
contrasts1.7$Outcome = v3.7
contrasts1.8$Outcome = v3.8
contrasts1.9$Outcome = v3.9
contrasts1.10$Outcome = v3.10
contrasts1.11$Outcome = v3.11
contrasts1.12$Outcome = v3.12
contrasts1.13$Outcome = v3.13
contrasts1.14$Outcome = v3.14
contrasts1.15$Outcome = v3.15

fapcares = rbind(contrasts1.1, contrasts1.2, contrasts1.3, contrasts1.4,
                  contrasts1.5, contrasts1.6, contrasts1.7, contrasts1.8, contrasts1.9,
                  contrasts1.10, contrasts1.11, contrasts1.12, contrasts1.13, contrasts1.14, contrasts1.15)
fapcares = fapcares %>% arrange(p.value)

fapcares$BH = p.adjust(fapcares$p.value, method = "BH", n = length(fapcares$p.value))
fapcares$BY = p.adjust(fapcares$p.value, method = "BY", n = length(fapcares$p.value))

fapcares$expestimate = exp(fapcares$estimate)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.1)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.2)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.3)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.4)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.5)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.6)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.7)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.8)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.9)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.10)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.11)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.12)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.13)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.14)

fapcares %>% filter(BH < 0.06) %>% filter(Outcome == v3.15)

```

# Group B


Perform a PCA on MVA85A priming input data in Group B. PC1 should be retained.

```{r}

mat1.2B = tmelt_1B[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

pca1.2B = mat1.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca1.2B_wide = pca1.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca1.2B_mat = as.matrix(pca1.2B_wide[, 2:3], nrow = nrow(pca1.2B_wide), ncol = 2)
rownames(pca1.2B_mat) = pca1.2B_wide$Outcome

pca1.2Bres = princomp(pca1.2B_mat, cor = TRUE, scores = TRUE)
summary(pca1.2Bres) # Component 1 should suffice

fviz_eig(pca1.2Bres, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```


PC1 explains MVA85A priming differences at the time of BCG and 1 week later.

```{r}
fviz_contrib(pca1.2Bres, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```

There are 3 immune outcomes making large contributions.

```{r}
fviz_contrib(pca1.2Bres, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```

```{r}
contrib1.2B.1 = fviz_contrib(pca1.2Bres, axes = 1, choice = "ind")

pc1dat = contrib1.2B.1$data[which(contrib1.2B.1$data$contrib >= 10), ]

pc1names = as.character(unique(c(pc1dat$name)))

mva_pca_setB = pc1names
```


Assuming that the subsets are independent, we can perform corrections within subset. Retrieve the fitted models.

```{r}

BM_1.1 = glmmTMB(O9 ~ Treatment*Time + Gender*Time + (1| ID), data = groupB2, family = tweedie(link = "log"))
BS_1.1 = summary(BM_1.1)

BM_1.2 = glmmTMB(O13 ~ Treatment*Time + Gender*Time + (1| ID), data = groupB2, family = poisson(link = "log"))
BS_1.2 = summary(BM_1.2)

BM_1.3 = glmmTMB(O16 ~ Treatment*Time + Gender*Time + (Time| ID), data = groupB2, family = Gamma(link = "log"))
BS_1.3 = summary(BM_1.3)

n1B = length(mva_pca_setB)
v1.1 = varB[9]
v1.2 = varB[13]
v1.3 = varB[16]

```

Create a contrast matrix for the predetermined pairwise comparisons.

```{r}

# Extract combinations of the levels

combinations = data.frame(emmeans(BM_1.1, ~ Treatment * Time))
combination_names = paste(combinations$Treatment, combinations$Time, sep = "_")

# Define the list of contrasts

contrast_list = list(
  
  # Comparisons within Control
  
  "Control_T2_vs_T1" = setNames(c(1, 0, -1, 0), combination_names),
  
  # Comparisons within MVA85A
  
  "MVA85A_T2_vs_T1" = setNames(c(0, 1, 0, -1), combination_names),
  
  # Comparisons between Control and MVA85A
  
  "T2_Control_vs_MVA85A" = setNames(c(1, -1, 0, 0), combination_names),
  "T1_Control_vs_MVA85A" = setNames(c(0, 0, 1, -1), combination_names)
)

contrast_list
```

Estimate and apply corrections for MVA85A priming subset. We find no differences.

```{r}

emmC1.1 = emmeans(BM_1.1, ~ Treatment * Time)
emmC1.2 = emmeans(BM_1.2, ~ Treatment * Time)
emmC1.3 = emmeans(BM_1.3, ~ Treatment * Time)

# Apply custom contrasts
contrasts1.1 = data.frame(contrast(emmC1.1, method = contrast_list, adjust = "none"))
contrasts1.2 = data.frame(contrast(emmC1.2, method = contrast_list, adjust = "none"))
contrasts1.3 = data.frame(contrast(emmC1.3, method = contrast_list, adjust = "none"))

contrasts1.1$Outcome = v1.1
contrasts1.2$Outcome = v1.2
contrasts1.3$Outcome = v1.3

mvapcaresB = rbind(contrasts1.1, contrasts1.2, contrasts1.3)
mvapcaresB = mvapcaresB %>% arrange(p.value)

mvapcaresB$BH = p.adjust(mvapcaresB$p.value, method = "BH", n = length(mvapcaresB$p.value))
mvapcaresB$BY = p.adjust(mvapcaresB$p.value, method = "BY", n = length(mvapcaresB$p.value))

mvapcaresB$expestimate = exp(mvapcaresB$estimate)

mvapcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v1.1)
mvapcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v1.2)
mvapcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v1.3)

```

Perform a PCA on QFT input data for Group B. One PC is required.

```{r}

mat2.2B = tmelt_2B[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

pca2.2B = mat2.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca2.2B_wide = pca2.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca2.2B_mat = as.matrix(pca2.2B_wide[, 2:3], nrow = nrow(pca2.2B_wide), ncol = 2)
rownames(pca2.2B_mat) = pca2.2B_wide$Outcome

pca2.2Bres = princomp(pca2.2B_mat, cor = TRUE, scores = TRUE)
summary(pca2.2Bres) # Component 1 should suffice

fviz_eig(pca2.2Bres, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```

PC1 explains QFT differences at the time of BCG and 1 week later.

```{r}
fviz_contrib(pca2.2Bres, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))


```


There are 7 immune outcomes making large contributions.

```{r}

fviz_contrib(pca2.2Bres, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```

```{r}
contrib2.2B.1 = fviz_contrib(pca2.2Bres, axes = 1, choice = "ind")

pc1dat = contrib2.2B.1$data[which(contrib2.2B.1$data$contrib >= 8), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

qft_pca_setB = pcnames1

```

Assuming that the subsets are independent, we can perform corrections within subset. Retrieve the fitted models.

```{r}

BM_2.1 = glmmTMB(O8 ~ QFT*Time + Gender*Time + (1| ID), data = groupB2, family = nbinom1(link = "log"))
BS_2.1 = summary(BM_2.1)

BM_2.2 = glmmTMB(O10 ~ QFT*Time + Gender*Time + (1| ID), data = groupB2, family = tweedie(link = "log"))
BS_2.2 = summary(BM_2.2)

BM_2.3 = glmmTMB(O11 ~ QFT*Time + Gender*Time + (1| ID), data = groupB2, family = poisson(link = "log"))
BS_2.3 = summary(BM_2.3)

BM_2.4 = glmmTMB(O15 ~ QFT*Time + Gender*Time + (1| ID), data = groupB2, family = poisson(link = "log"))
BS_2.4 = summary(BM_2.4)

BM_2.5 = glmmTMB(O12 ~ QFT*Time + Gender*Time + (1| ID), data = groupB2, family = Gamma(link = "log"))
BS_2.5 = summary(BM_2.5)

BM_2.6 = glmmTMB(O16 ~ QFT*Time + Gender*Time + (Time| ID), data = groupB2, family = Gamma(link = "log"))
BS_2.6 = summary(BM_2.6)

n2B = length(qft_pca_setB)
v2.1 = varB[8]
v2.2 = varB[10]
v2.3 = varB[11]
v2.4 = varB[15]
v2.5 = varB[12]
v2.6 = varB[16]

```

Create a contrast matrix for the predetermined pairwise comparisons.

```{r}

# Extract combinations of the levels

combinations = data.frame(emmeans(BM_2.1, ~ QFT * Time))
combination_names = paste(combinations$QFT, combinations$Time, sep = "_")

# Define the list of contrasts

contrast_list = list(
  
  # Comparisons within Negative
  
  "Negative_T2_vs_T1" = setNames(c(1, 0, -1, 0), combination_names),
  
  # Comparisons within Positive
  
  "Positive_T2_vs_T1" = setNames(c(0, 1, 0, -1), combination_names),
  
  # Comparisons between Negative and Positive
  
  "T2_Negative_vs_Positive" = setNames(c(1, -1, 0, 0), combination_names),
  "T1_Negative_vs_Positive" = setNames(c(0, 0, 1, -1), combination_names)
)

contrast_list
```

Estimate and apply corrections for QFT subset. No significant results.

```{r}

emm2.1 = emmeans(BM_2.1, ~ QFT * Time)
emm2.2 = emmeans(BM_2.2, ~ QFT * Time)
emm2.3 = emmeans(BM_2.3, ~ QFT * Time)
emm2.4 = emmeans(BM_2.4, ~ QFT * Time)
emm2.5 = emmeans(BM_2.5, ~ QFT * Time)
emm2.6 = emmeans(BM_2.6, ~ QFT * Time)

# Apply custom contrasts
contrasts2.1 = data.frame(contrast(emm2.1, method = contrast_list, adjust = "none"))
contrasts2.2 = data.frame(contrast(emm2.2, method = contrast_list, adjust = "none"))
contrasts2.3 = data.frame(contrast(emm2.3, method = contrast_list, adjust = "none"))
contrasts2.4 = data.frame(contrast(emm2.4, method = contrast_list, adjust = "none"))
contrasts2.5 = data.frame(contrast(emm2.5, method = contrast_list, adjust = "none"))
contrasts2.6 = data.frame(contrast(emm2.6, method = contrast_list, adjust = "none"))

contrasts2.1$Outcome = v2.1
contrasts2.2$Outcome = v2.2
contrasts2.3$Outcome = v2.3
contrasts2.4$Outcome = v2.4
contrasts2.5$Outcome = v2.5
contrasts2.6$Outcome = v2.6

qftpcaresB = rbind(contrasts2.1, contrasts2.2, contrasts2.3, contrasts2.4, contrasts2.5, contrasts2.6)
qftpcaresB = qftpcaresB %>% arrange(p.value)

qftpcaresB$BH = p.adjust(qftpcaresB$p.value, method = "BH", n = length(qftpcaresB$p.value))
qftpcaresB$BY = p.adjust(qftpcaresB$p.value, method = "BY", n = length(qftpcaresB$p.value))

qftpcaresB$expestimate = exp(qftpcaresB$estimate)

qftpcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v2.1)
qftpcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v2.2)
qftpcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v2.3)
qftpcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v2.4)
qftpcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v2.5)
qftpcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v2.6)

```

Perform a PCA on FA input data. PC1 and PC2 explain sufficient input variance.

```{r}

mat3.2B = tmelt_3B[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

pca3.2B = mat3.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca3.2B_wide = pca3.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca3.2B_mat = as.matrix(pca3.2B_wide[, 2:9], nrow = nrow(pca3.2B_wide), ncol = 8)
rownames(pca3.2B_mat) = pca3.2B_wide$Outcome

pca3.2Bres = princomp(pca3.2B_mat, cor = TRUE, scores = TRUE)
summary(pca3.2Bres) # Component 1 should suffice

fviz_eig(pca3.2Bres, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```

PC1 isn't easy to describe but PC2 mostly describes 8 weeks after BCG - predominantly for FA1.

```{r}

fviz_contrib(pca3.2Bres, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca3.2Bres, axes = 2, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))


```

PC1 has large contributions from 2 immune outcomes. PC2 has large contributions from 4 immune outcomes.

```{r}

fviz_contrib(pca3.2Bres, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca3.2Bres, axes = 2, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```

```{r}
contrib3.2B.1 = fviz_contrib(pca3.2Bres, axes = 1, choice = "ind")
contrib3.2B.2 = fviz_contrib(pca3.2Bres, axes = 2, choice = "ind")

pc1dat = contrib3.2B.1$data[which(contrib3.2B.1$data$contrib >= 10), ]
pc2dat = contrib3.2B.2$data[which(contrib3.2B.2$data$contrib >= 10), ]

pcnames1 = as.character(unique(c(pc1dat$name, pc2dat$name)))

fa_pca_setB = pcnames1
```

Assuming that the subsets are independent, we can perform corrections within subset. Retrieve the fitted models.

```{r}

BM_3.1 = glmmTMB(O9 ~ FA*Time + Gender*Time + (1| ID), data = groupB2, family = tweedie(link = "log"))
BS_3.1 = summary(BM_3.1)

BM_3.2 = glmmTMB(O8 ~ FA*Time + Gender*Time + (1| ID), data = groupB2, family = nbinom1(link = "log"))
BS_3.2 = summary(BM_3.2)

BM_3.3 = glmmTMB(O15 ~ FA*Time + Gender*Time + (1| ID), data = groupB2, family = poisson(link = "log"))
BS_3.3 = summary(BM_3.3)

BM_3.4 = glmmTMB(O14 ~ FA*Time + Gender*Time + (Time| ID), data = groupB2, family = t_family(link = "log"))
BS_3.4 = summary(BM_3.4)

BM_3.5 = glmmTMB(O18 ~ FA*Time + Gender*Time + (Time| ID), data = groupB2, family = Gamma(link = "log"))
BS_3.5 = summary(BM_3.5)

BM_3.6 = glmmTMB(O19 ~ FA*Time + Gender*Time + (1| ID), data = groupB2, family = Gamma(link = "log"))
BS_3.6 = summary(BM_3.6)

n3B = length(fa_pca_setB)
v3.1 = varB[9]
v3.2 = varB[8]
v3.3 = varB[15]
v3.4 = varB[14]
v3.5 = varB[18]
v3.6 = varB[19]

```

Create a contrast matrix for the predetermined pairwise comparisons.

```{r}

# Extract combinations of the levels

combinations = data.frame(emmeans(BM_3.1, ~ FA * Time))
combination_names = paste(combinations$FA, combinations$Time, sep = "_")

# Define the list of contrasts

contrast_list = list(
  
  # Comparisons within FA0
  
  "FA0_T2_vs_T1" = setNames(c(1, 0, 0, 0, -1, 0, 0, 0), combination_names),
  
  # Comparisons within FA1
  
  "FA1_T2_vs_T1" = setNames(c(0, 1, 0, 0, 0, -1, 0, 0), combination_names),
  
  # Comparisons within FA2
  
  "FA2_T2_vs_T1" = setNames(c(0, 0, 1, 0, 0, 0, -1, 0), combination_names),
  
  # Comparisons within FA3
  
  "FA3_T2_vs_T1" = setNames(c(0, 0, 0, 1, 0, 0, 0, -1), combination_names),
  
  
  # Comparisons between FA0 and FA3
  
  "T2_FA0_vs_FA3" = setNames(c(1, 0, 0, -1, 0, 0, 0, 0), combination_names),
  "T1_FA0_vs_FA3" = setNames(c(0, 0, 0, 0, 1, 0, 0, -1), combination_names),
  
  # Comparisons between FA0 and FA1
  
  "T2_FA0_vs_FA1" = setNames(c(1, -1, 0, 0, 0, 0, 0, 0), combination_names),
  "T1_FA0_vs_FA1" = setNames(c(0, 0, 0, 0, 1, -1, 0, 0), combination_names),
  
  
  # Comparisons between FA2 and FA3
  
  "T2_FA2_vs_FA3" = setNames(c(0, 0, 1, -1, 0, 0, 0, 0), combination_names),
  "T1_FA2_vs_FA3" = setNames(c(0, 0, 0, 0, 0, 0, 1, -1), combination_names)
  
  
)

contrast_list
```

Estimate and apply corrections. There are some differences.
```{r}

emm3.1 = emmeans(BM_3.1, ~ FA * Time)
emm3.2 = emmeans(BM_3.2, ~ FA * Time)
emm3.3 = emmeans(BM_3.3, ~ FA * Time)
emm3.4 = emmeans(BM_3.4, ~ FA * Time)
emm3.5 = emmeans(BM_3.5, ~ FA * Time)
emm3.6 = emmeans(BM_3.6, ~ FA * Time)

# Apply custom contrasts
contrasts3.1 = data.frame(contrast(emm3.1, method = contrast_list, adjust = "none"))
contrasts3.2 = data.frame(contrast(emm3.2, method = contrast_list, adjust = "none"))
contrasts3.3 = data.frame(contrast(emm3.3, method = contrast_list, adjust = "none"))
contrasts3.4 = data.frame(contrast(emm3.4, method = contrast_list, adjust = "none"))
contrasts3.5 = data.frame(contrast(emm3.5, method = contrast_list, adjust = "none"))
contrasts3.6 = data.frame(contrast(emm3.6, method = contrast_list, adjust = "none"))

contrasts3.1$Outcome = v3.1
contrasts3.2$Outcome = v3.2
contrasts3.3$Outcome = v3.3
contrasts3.4$Outcome = v3.4
contrasts3.5$Outcome = v3.5
contrasts3.6$Outcome = v3.6

fapcaresB = rbind(contrasts3.1, contrasts3.2, contrasts3.3, contrasts3.4, contrasts3.5, contrasts3.6)
fapcaresB = fapcaresB %>% arrange(p.value)

fapcaresB$BH = p.adjust(fapcaresB$p.value, method = "BH", n = length(fapcaresB$p.value))
fapcaresB$BY = p.adjust(fapcaresB$p.value, method = "BY", n = length(fapcaresB$p.value))

fapcaresB$expestimate = exp(fapcaresB$estimate)

fapcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v3.1)
fapcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v3.2)
fapcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v3.3)
fapcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v3.4)
fapcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v3.5)
fapcaresB %>% filter(BH < 0.06) %>% filter(Outcome == v3.6)


```

```{r}

# Group A set comparison

Aset_list = list(MVA85A = mva_pca_set, QFT = qft_pca_set, FA = fa_pca_set)

# Number per set

length(mva_pca_set)
length(qft_pca_set)
length(fa_pca_set)

# Number of unique immune outcomes
unique(c(mva_pca_set, qft_pca_set, fa_pca_set))

Aresult = sapply(allA, function(x) {
  sapply(Aset_list, function(vec) as.numeric(x %in% vec))
})

Aset_res = t(Aresult)
Amelt = melt(Aset_res)
colnames(Amelt) = c("Outcome", "Variable", "Indicator")
Amelt$Indicator = as.logical(Amelt$Indicator)

ggplot(Amelt, aes(x = Variable, y = Outcome, fill = Indicator)) +
  geom_tile(color = "black") + theme_bw() +
  theme(axis.text.y = element_text(size=9, family = "TT Arial"),
        axis.text.x = element_text(size=10, angle = 0, family = "TT Arial", face = "bold"),
        axis.title.y = element_blank(), axis.title.x = element_blank(), legend.position = "none") +
scale_fill_manual(name = "Selected", breaks = c("FALSE", "TRUE"), values = c("lightgrey", "darkcyan"))


```

```{r}

# Group A set comparison

Bset_list = list(MVA85A = mva_pca_setB, QFT = qft_pca_setB, FA = fa_pca_setB)

# Number per set

length(mva_pca_setB)
length(qft_pca_setB)
length(fa_pca_setB)

# Number of unique immune outcomes
unique(c(mva_pca_setB, qft_pca_setB, fa_pca_setB))

Bresult = sapply(allB, function(x) {
  sapply(Bset_list, function(vec) as.numeric(x %in% vec))
})

Bset_res = t(Bresult)
Bmelt = melt(Bset_res)
colnames(Bmelt) = c("Outcome", "Variable", "Indicator")
Bmelt$Indicator = as.logical(Bmelt$Indicator)

ggplot(Bmelt, aes(x = Variable, y = Outcome, fill = Indicator)) +
  geom_tile(color = "black") + theme_bw() +
  theme(axis.text.y = element_text(size=9, family = "TT Arial"),
        axis.text.x = element_text(size=10, angle = 0, family = "TT Arial", face = "bold"),
        axis.title.y = element_blank(), axis.title.x = element_blank(), legend.position = "none") +
scale_fill_manual(name = "Selected", breaks = c("FALSE", "TRUE"), values = c("lightgrey", "darkcyan"))

```

## Sex

Apply PCA to standardised regression coefficients for sex and interactions between sex and time points. In Group A, the first PC explains sufficient variance in the standardised regression coefficients. 

```{r}

mat4.2A = tmelt_4A[, c("Outcome", "Group", "Coefficient", "value")]

# Restructure the data frame

mat4.2A$OutcomeGroup = paste(mat4.2A$Outcome, mat4.2A$Group)
mat4.2A2 = mat4.2A[, c("OutcomeGroup", "Coefficient", "value")]

mat4.2A2_wide = mat4.2A2 %>%
  pivot_wider(names_from = Coefficient, id_cols = OutcomeGroup, values_from = value)

mat4.2A2 = as.matrix(mat4.2A2_wide[, 2:4], nrow = nrow(mat4.2A2_wide), ncol = 3)
row.names(mat4.2A2) = mat4.2A2_wide$OutcomeGroup

pca4.2Ares = princomp(mat4.2A2, cor = TRUE, scores = TRUE)
summary(pca4.2Ares) # Component 1 should suffice

fviz_eig(pca4.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```

PC1 primarily describes differences prior to BCG.

```{r}

fviz_contrib(pca4.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))


```

PC1 has many contributions as the coefficients are measured for each VOI.

```{r}

fviz_contrib(pca4.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 50) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 8, angle = 90, vjust = 0, hjust = 1),
        axis.text.y = element_text(size = 10))

```

```{r}
contrib4.2A = fviz_contrib(pca4.2Ares, axes = 1, choice = "ind")

pc1dat = contrib4.2A$data[which(contrib4.2A$data$contrib >= 0.76), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

sex_pca_setA = pcnames1

split_after_match = function(string, matches) {
  # Create a regex pattern that matches any word in 'matches'
  pattern <- paste(matches, collapse = "|")
  
  # Extract the part before the match
  outcome = sub(paste0("(.*?)\\s*(", pattern, ").*"), "\\1", string)
  
  # Extract the matched word and everything after it
  group =  sub(paste0(".*?(", pattern, ".*)"), "\\1", string)
  
  # Return as a named vector or list for clarity
  c(Outcome = outcome, Group = group)
}

# Apply the function to each string
result = t(sapply(sex_pca_setA, split_after_match, matches = matches))

# Convert to data frame for easy viewing
sex_df = as.data.frame(result, stringsAsFactors = FALSE)

# View the result
print(sex_df)

mva_sex_namesA = unlist(as.vector(sex_df %>% filter(Group == "MVA85A") %>% select(Outcome)))
qft_sex_namesA = unlist(as.vector(sex_df %>% filter(Group == "QFT") %>% select(Outcome)))
fa_sex_namesA = unique(unlist(as.vector(sex_df %>% filter(Group %in% c("FA - FA", "FA - BA")) %>% select(Outcome))))

# For all VOI
all_sex_namesA = Reduce(intersect, list(mva_sex_namesA, qft_sex_namesA, fa_sex_namesA))

find_exclusive_pairs = function(vec1, vec2, exclude_vec) {
  # Find common elements in vec1 and vec2
  common <- intersect(vec1, vec2)
  # Exclude elements that are in exclude_vec
  setdiff(common, exclude_vec)
}

# For MVA85A and QFT but not FA

mva_qft_namesA = find_exclusive_pairs(mva_sex_namesA, qft_sex_namesA, fa_sex_namesA)

# For MVA85A and FA but not QFT

mva_fa_namesA = find_exclusive_pairs(mva_sex_namesA, fa_sex_namesA, qft_sex_namesA)

# For QFT and FA but not MVA85A

qft_fa_namesA = find_exclusive_pairs(qft_sex_namesA, fa_sex_namesA, fa_sex_namesA)

find_exclusive = function(target_vec, exclude_vec1, exclude_vec2) {
  # Combine the two exclusion vectors
  combined_exclusions <- union(exclude_vec1, exclude_vec2)
  # Find elements in target_vec that are not in the combined exclusions
  setdiff(target_vec, combined_exclusions)
}

# For MVA85A only

mva_namesA = find_exclusive(mva_sex_namesA, qft_sex_namesA, fa_sex_namesA)

# For QFT only

qft_namesA = find_exclusive(qft_sex_namesA, mva_sex_namesA, fa_sex_namesA)

# For FA only

fa_namesA = find_exclusive(fa_sex_namesA, mva_sex_namesA, qft_sex_namesA)

```

```{r}

mat4.2B = tmelt_4B[, c("Outcome", "Group", "Coefficient", "value")]

# Restructure the data frame

mat4.2B$OutcomeGroup = paste(mat4.2B$Outcome, mat4.2B$Group)
mat4.2B2 = mat4.2B[, c("OutcomeGroup", "Coefficient", "value")]

mat4.2B2_wide = mat4.2B2 %>%
  pivot_wider(names_from = Coefficient, id_cols = OutcomeGroup, values_from = value)

mat4.2B2 = as.matrix(mat4.2B2_wide[, 2:3], nrow = nrow(mat4.2B2_wide), ncol = 2)
row.names(mat4.2B2) = mat4.2B2_wide$OutcomeGroup

pca4.2Bres = princomp(mat4.2B2, cor = TRUE, scores = TRUE)
summary(pca4.2Bres) # Component 1 should suffice

fviz_eig(pca4.2Bres, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))


```

PC1 has many contributions as the coefficients are measured for each VOI.

```{r}

fviz_contrib(pca4.2Bres, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 50) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 8, angle = 90, vjust = 0, hjust = 1),
        axis.text.y = element_text(size = 10))

```
```{r}
contrib4.2B = fviz_contrib(pca4.2Bres, axes = 1, choice = "ind")

pc1dat = contrib4.2B$data[which(contrib4.2B$data$contrib >= 2.1), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

sex_pca_setB = pcnames1

matches = unique(mat4.2B$Group)

# Apply the function to each string
result = t(sapply(sex_pca_setB, split_after_match, matches = matches))

# Convert to data frame for easy viewing
sex_dfB = as.data.frame(result, stringsAsFactors = FALSE)

# View the result
print(sex_dfB)

mva_sex_namesB = unlist(as.vector(sex_dfB %>% filter(Group == "MVA85A") %>% select(Outcome)))
qft_sex_namesB = unlist(as.vector(sex_dfB %>% filter(Group == "QFT") %>% select(Outcome)))
fa_sex_namesB = unique(unlist(as.vector(sex_dfB %>% filter(Group %in% c("FA - FA", "FA - BA")) %>% select(Outcome))))

# For all VOI
all_sex_namesB = Reduce(intersect, list(mva_sex_namesB, qft_sex_namesB, fa_sex_namesB))

# For MVA85A and QFT but not FA

mva_qft_namesB = find_exclusive_pairs(mva_sex_namesB, qft_sex_namesB, fa_sex_namesB)

# For MVA85A and FA but not QFT

mva_fa_namesB = find_exclusive_pairs(mva_sex_namesB, fa_sex_namesB, qft_sex_namesB)

# For QFT and FA but not MVA85A

qft_fa_namesB = find_exclusive_pairs(qft_sex_namesB, fa_sex_namesB, fa_sex_namesB)

# For MVA85A only

mva_namesB = find_exclusive(mva_sex_namesB, qft_sex_namesB, fa_sex_namesB)

# For QFT only

qft_namesB = find_exclusive(qft_sex_namesB, mva_sex_namesB, fa_sex_namesB)

# For FA only

fa_namesB = find_exclusive(fa_sex_namesB, mva_sex_namesB, qft_sex_namesB)

```
