---
title: "Outcome Selection (Clustering)"
author: "Shannon Holcroft"
format: revealjs
---

## Data Preparation

```{r setup, include = FALSE}

knitr::opts_chunk$set(warning = FALSE, message = FALSE)

setwd("C:/Users/HLCSH/OneDrive/Documents/MSc 2023-2024/MSc Dissertation/MScDissertationCodeBase")

# Load packages
library(readxl)
library(tidyverse)
library(ggplot2)
library(reshape2)
library(glmmTMB)
library(MASS)
library(DHARMa)
options(scipen = 999)

# Read in group data

groupA = read_xlsx("data/groupAinfantsData_AD_23Feb2023.xlsx")
varA = colnames(groupA[, 17:56])

groupB = read_xlsx("data/groupBinfantsData_AD_23Feb2023.xlsx")
varB = colnames(groupB[, 16:34])

# Change variable names

## Study design and covariates

colnames(groupA)[1:4] = c("ID", "Group", "Time", "Treatment")
groupA$Time = as.factor(groupA$Time)
colnames(groupA)[10] = c("QFT")
colnames(groupA)[12:13] = c("Feeding", "Antibiotic")

colnames(groupB)[1:4] =  c("ID", "Group", "Time", "Treatment")
groupB$Time = as.factor(groupB$Time)
colnames(groupB)[10] = c("QFT")
colnames(groupB)[12:13] = c("Feeding", "Antibiotic")

# Create new dummy variables for feeding and antibiotic

groupA$FA = ifelse(groupA$Feeding == "Breast Milk" & groupA$Antibiotic == "Yes", 3, ifelse(groupA$Feeding == "Breast Milk" & groupA$Antibiotic == "No", 2, ifelse(groupA$Feeding == "Formula" & groupA$Antibiotic == "No", 1, 0)))
groupA$FA = factor(groupA$FA)

groupB$FA = ifelse(groupB$Feeding == "Breast Milk" & groupB$Antibiotic == "Y", 3, ifelse(groupB$Feeding == "Breast Milk" & groupB$Antibiotic == "N", 2, ifelse(groupB$Feeding == "Formula" & groupB$Antibiotic == "N", 1, 0)))
groupB$FA = factor(groupB$FA)

## Create immune response data sets

# Rename by number

groupA = rename_with(.data = groupA, .fn = ~ paste0("O", 1:length(varA)), .cols = 17:56)
groupB = rename_with(.data = groupB, .fn = ~ paste0("O", 1:length(varB)), .cols = 16:34)

# Drop indeterminate QFT observations
indet_idsA = groupA[which(groupA$QFT == "Indeterminate"), ]$ID
indet_idsB = groupB[which(groupB$QFT == "Indeterminate"), ]$ID

groupA = groupA[-which(groupA$ID %in% indet_idsA), ]
groupB = groupB[-which(groupB$ID %in% indet_idsB), ]

# Make time and variables of interest factors

colnam = c("Treatment", "Time", "Gender", "QFT", "FA")
groupA[colnam] = lapply(groupA[colnam], factor)
groupB[colnam] = lapply(groupB[colnam], factor)

# Set reference levels for Group A

groupA$Time = factor(groupA$Time, levels = c("112", "56", "365"))

# Divide Group B by time points and set reference levels

groupB1 = groupB[, -c(16:18, 23:34)]
groupB1 = groupB1[-which(groupB1$Time %in% c("63", "0", "56")), ]
groupB1$Time = factor(groupB1$Time, levels = c("112", "365"))

groupB2 = groupB[, -c(16:22)]
groupB2 = groupB2[-which(groupB2$Time %in% c("112", "0", "365")), ]
groupB2$Time = factor(groupB2$Time, levels = c("63", "56"))

# Relevel for coefficient extraction

groupAre1 = groupA
groupAre1$FA = factor(groupAre1$FA, levels = c(3, 0, 1, 2))
groupAre1[colnam] = lapply(groupAre1[colnam], factor)

groupB1re1 = groupB1
groupB1re1$FA = factor(groupB1re1$FA, levels = c(3, 0, 1, 2))
groupB1re1[colnam] = lapply(groupB1re1[colnam], factor)

groupB2re1 = groupB2
groupB2re1$FA = factor(groupB2re1$FA, levels = c(3, 0, 1, 2))
groupB2re1[colnam] = lapply(groupB2re1[colnam], factor)

sort_row_values = function(data) {
  
  # Ensure data is a data frame
  data = as.data.frame(data)
  
  # Swap values where LowerCI > UpperCI
  swap_indices = which(data$LowerCI > data$UpperCI)
  data[swap_indices, c("LowerCI", "UpperCI")] = data[swap_indices, c("UpperCI", "LowerCI")]
  
  return(data)
}



```

Read in the data extracted from the fitted GLMMs for each group and variable of interest.

```{r, echo=FALSE}

library(tidyverse)
library(reshape2)
library(cluster)
library(factoextra)
library(ggdendro)
library(glmmTMB)
library(emmeans)

# Read in combined data

alldat = read.csv("combined_data.csv")[-1]

# Drop very infrequently observed immune outcomes, antibody titres and assays

droplist = c("%CD8+ totIL17+", "%CD8+ totIL2+", "%CD8+ totIL22+", "Baby Anti-BCG IgA (AUC)", "Baby Anti-BCG IgM (AUC)", "Baby Anti-BCG IgG (AUC)", "Elispot (BCG)")

alldat = alldat[-which(alldat$Outcome %in% droplist), ]

# Change names for display for certain immune outcomes

namelist = c("bulk CD8+/% R7-RA-", "bulk CD8+/% R7-RA+", "bulk CD8+/% R7+RA-", "bulk CD8+/% R7+RA+", "CD8+ ANYcytok+")
namechange = c("Bulk CD8+/% R7-RA-", "Bulk CD8+/% R7-RA+", "Bulk CD8+/% R7+RA-", "Bulk CD8+/% R7+RA+", "%CD8+ ANYcytok+")

alldat = alldat %>% mutate(Outcome = if_else(Outcome %in% namelist, recode(Outcome, !!!setNames(namechange, namelist)), Outcome))

# Separate into Group A and Group B

datA = alldat %>% filter(Arm == "A")
allA = unique(datA$Outcome)

datB = alldat %>% filter(Arm == "B")
allB = unique(datB$Outcome)

# Separate by variables of interest

dat1A = datA %>% filter(Group == "MVA85A") %>% filter(Coefficient %in% c("TreatmentMVA85A", "TreatmentMVA85A:Time56", "TreatmentMVA85A:Time365"))
dat1B = datB %>% filter(Group == "MVA85A") %>% filter(Coefficient %in% c("TreatmentMVA85A", "TreatmentMVA85A:Time56", "TreatmentMVA85A:Time365"))

dat2A = datA %>% filter(Group == "QFT") %>% filter(Coefficient %in% c("QFTPositive", "QFTPositive:Time56", "QFTPositive:Time365"))
dat2B = datB %>% filter(Group == "QFT") %>% filter(Coefficient %in% c("QFTPositive", "QFTPositive:Time56", "QFTPositive:Time365"))

dat3A = datA %>% filter(Group %in% c("FA - FA", "FA - BA"))

# Retain specific comparisons of interest: FA0 in FA-BA, FA1 in FA-FA, FA2 in FA-FA, FA3 in FA-BA

dat3.1.1A = dat3A %>% filter(Group == "FA - FA") %>% filter(Coefficient %in% c("FA1", "FA3", "FA1:Time56", "FA1:Time365", "FA3:Time56", "FA3:Time365", "FA1:Time63", "FA3:Time63"))
dat3.1.2A = dat3A %>% filter(Group == "FA - BA") %>% filter(Coefficient %in% c("FA0", "FA2", "FA0:Time56", "FA2:Time56", "FA2:Time365",  "FA0:Time365", "FA0:Time63","FA2:Time63"))
      
dat3A = rbind(dat3.1.1A, dat3.1.2A)

dat3B = datB %>% filter(Group %in% c("FA - FA", "FA - BA"))

# Retain specific comparisons of interest: FA0 in FA-BA, FA1 in FA-FA, FA2 in FA-FA, FA3 in FA-BA

dat3.1.1B = dat3B %>% filter(Group == "FA - FA") %>% filter(Coefficient %in% c("FA1", "FA3", "FA1:Time56", "FA1:Time365", "FA3:Time56", "FA3:Time365", "FA1:Time63", "FA3:Time63"))
dat3.1.2B = dat3B %>% filter(Group == "FA - BA") %>% filter(Coefficient %in% c("FA0", "FA2", "FA0:Time56", "FA2:Time56", "FA2:Time365",  "FA0:Time365", "FA0:Time63","FA2:Time63"))
      
dat3B = rbind(dat3.1.1B, dat3.1.2B)

dat4A = datA %>% filter(Coefficient %in% c("GenderM", "Time56:GenderM", "Time365:GenderM"))
dat4B = datB %>% filter(Coefficient %in% c("GenderM", "Time56:GenderM", "Time365:GenderM"))

# Create a clustering colour palette

cols = c("darkgrey", "darkblue", "darkcyan", "#ff7f0e", "firebrick", "darkgreen","hotpink", "mediumorchid4")

```

Create data frames for clustering

```{r}
# Create long format data frames for groups A and B

tmelt_1A = melt(dat1A) %>% filter(variable == "EstOverSE")
tmelt_2A = melt(dat2A) %>% filter(variable == "EstOverSE")
tmelt_3A = melt(dat3A) %>% filter(variable == "EstOverSE")
tmelt_4A = melt(dat4A) %>% filter(variable == "EstOverSE")

tmelt_1B = melt(dat1B) %>% filter(variable == "EstOverSE")
tmelt_2B = melt(dat2B) %>% filter(variable == "EstOverSE")
tmelt_3B = melt(dat3B) %>% filter(variable == "EstOverSE")
tmelt_4B = melt(dat4B) %>% filter(variable == "EstOverSE")

```

Starting with MVA85A in Groups A and B, create Pearson distance matrices of standardised regression coefficients for clustering.

```{r}

mat1.2A = tmelt_1A[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

mat1.2A = mat1.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

mat1.2A_wide = mat1.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

mat1.2A = as.matrix(mat1.2A_wide[, 2:4], nrow = nrow(mat1.2A_wide), ncol = 3)
row.names(mat1.2A) = mat1.2A_wide$Outcome
dist1.2A = get_dist(mat1.2A, "pearson")

mat1.2B = tmelt_1B[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

mat1.2B = mat1.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

mat1.2B_wide = mat1.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

mat1.2B = as.matrix(mat1.2B_wide[, 2:3], nrow = nrow(mat1.2B_wide), ncol = 2)
row.names(mat1.2B) = mat1.2B_wide$Outcome
dist1.2B = get_dist(mat1.2B, "pearson")
```

Perform aggomerative hierarchical clustering on Pearson distance matrices of standardised regression coefficients. Average linkage is specified.
```{r}

res1.2.hclustA = as.hclust(agnes(dist1.2A, diss = TRUE, method = "average"))

res1.2.hclustB = as.hclust(agnes(dist1.2B, diss = TRUE, method = "average"))
```

There are 6 clusters for Group A. Perf+ Ki67+ CD4 is a singleton. There are 2 clusters for Group B.
```{r}

hcdata1.2A = dendro_data_k(res1.2.hclustA, 6)

p = plot_ggdendro(hcdata1.2A,
                  scale.color = cols,
                   direction   = "rl",
                   expand.y    = 0.2) 
p + ylab("\n Link Height") + geom_hline(yintercept = 0.15, linetype = "solid", size = 1) + theme_bw() +
  theme(axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
        axis.title.y = element_blank(),
        axis.text.x = element_text(size = 10, family = "Arial"),
        axis.text.y = element_text(size = 10, family = "Arial"))
  
hcdata1.2B = dendro_data_k(res1.2.hclustB, 2)

p = plot_ggdendro(hcdata1.2B,
                  scale.color = c("darkblue", "darkgreen"),
                   direction   = "rl",
                   expand.y    = 0.2) 
p + ylab("\n Link Height") + geom_hline(yintercept = 0.15, linetype = "solid", size = 1) + theme_bw() +
  theme(axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
        axis.title.y = element_blank(),
        axis.text.x = element_text(size = 10, family = "Arial"),
        axis.text.y = element_text(size = 10, family = "Arial"))

```

Extract the names of immune outcomes contained within each cluster. Number the clusters from top to bottom in order of appearance in the dendograms.

```{r}

clusters1.2A = cutree(res1.2.hclustA, k=6)


names6 = names(clusters1.2A[clusters1.2A == 1])
names4 = names(clusters1.2A[clusters1.2A == 2])
names2 = names(clusters1.2A[clusters1.2A == 3])
names5 = names(clusters1.2A[clusters1.2A == 4])
names1 = names(clusters1.2A[clusters1.2A == 5])
names3 = names(clusters1.2A[clusters1.2A == 6])

clusters1.2B = cutree(res1.2.hclustB, k=2)


names2B = names(clusters1.2B[clusters1.2B == 1])
names1B = names(clusters1.2B[clusters1.2B == 2])


```

Perform a PCA on Cluster 1 in Group A. PC1 explains the majority of the variance in the input data.

```{r}

mat1.2A = tmelt_1A[, c("Outcome", "Coefficient", "value")]
mat1.2A = mat1.2A %>% filter(Outcome %in% names1)

# Restructure the data frame

pca1.2A = mat1.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca1.2A_wide = pca1.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca1.2A_mat = as.matrix(pca1.2A_wide[, 2:4], nrow = nrow(pca1.2A_wide), ncol = 3)
rownames(pca1.2A_mat) = pca1.2A_wide$Outcome

pca1.2Ares = princomp(pca1.2A_mat, cor = TRUE, scores = TRUE)
summary(pca1.2Ares) # Component 1 should suffice

fviz_eig(pca1.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```

PC1 primarily describes the interaction between MVA85A priming and Time 56. This cluster likely contains immune outcomes showing group differences before BCG.

```{r}
fviz_contrib(pca1.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

Bulk CD8 R7+RA- and GrB Ki67+ CD4 make larger contributions to PC1 than the uniform expectation. They are selected to the Cluster 1 subset.
```{r}

fviz_contrib(pca1.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

contrib1.2A.1 = fviz_contrib(pca1.2Ares, axes = 1, choice = "ind")
pc1dat = contrib1.2A.1$data[which(contrib1.2A.1$data$contrib >= 30), ]
#pc2dat = contrib1.2A.2$data[which(contrib1.2A.2$data$contrib >= 3), ]

clust1Anames = as.character(unique(c(pc1dat$name)))

mva_pca_set1 = clust1Anames
```
Perform a PCA on Cluster 2 in Group A. PC1 explains the majority of the variance in the input data.

```{r}

mat1.2A = tmelt_1A[, c("Outcome", "Coefficient", "value")]
mat1.2A = mat1.2A %>% filter(Outcome %in% names2)

# Restructure the data frame

pca1.2A = mat1.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca1.2A_wide = pca1.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca1.2A_mat = as.matrix(pca1.2A_wide[, 2:4], nrow = nrow(pca1.2A_wide), ncol = 3)
rownames(pca1.2A_mat) = pca1.2A_wide$Outcome

pca1.2Ares = princomp(pca1.2A_mat, cor = TRUE, scores = TRUE)
summary(pca1.2Ares) # Component 1 should suffice

fviz_eig(pca1.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```


PC1 primarily describes the interaction between MVA85A priming and Time 56, but there is a smaller contribution by MVA85A priming 8 weeks after BCG than in Cluster 1.

```{r}
fviz_contrib(pca1.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

CD4 IL-2 and Bulk CD8 R7+RA+ make larger contributions than expected under uniformity. They are selected as the Cluster 2 subset.
```{r}
fviz_contrib(pca1.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```
```{r}
contrib1.2A.1 = fviz_contrib(pca1.2Ares, axes = 1, choice = "ind")
pc1dat = contrib1.2A.1$data[which(contrib1.2A.1$data$contrib >= 20), ]

clust2Anames = as.character(unique(c(pc1dat$name)))

mva_pca_set2 = clust2Anames

```

Do not perform a PCA on the singlton Cluster 3 in Group A. Perf+ %of Ki67+CD4 is the subset for Cluster 3.

```{r}
clustA3names = names3
mva_pca_set3 = clustA3names
```

Perform a PCA on Cluster 4. PC1 explains the majority of the variance in the input data.

```{r}

mat1.2A = tmelt_1A[, c("Outcome", "Coefficient", "value")]
mat1.2A = mat1.2A %>% filter(Outcome %in% names4)

# Restructure the data frame

pca1.2A = mat1.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca1.2A_wide = pca1.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca1.2A_mat = as.matrix(pca1.2A_wide[, 2:4], nrow = nrow(pca1.2A_wide), ncol = 3)
rownames(pca1.2A_mat) = pca1.2A_wide$Outcome

pca1.2Ares = princomp(pca1.2A_mat, cor = TRUE, scores = TRUE)
summary(pca1.2Ares) # Component 1 should suffice

fviz_eig(pca1.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```

Cluster 4 primarily describes variance in input data by MVA85A priming at the time of BCG and when the infant is 1 year old.
```{r}
fviz_contrib(pca1.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

Bulk CD4 R7-RA- and Bulk CD8 R7-RA- make large contributions and are selected as the Cluster 4 subset.
```{r}
fviz_contrib(pca1.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```


The names of these 3 immune outcomes are printed below.
```{r}
contrib1.2A.1 = fviz_contrib(pca1.2Ares, axes = 1, choice = "ind")
pc1dat = contrib1.2A.1$data[which(contrib1.2A.1$data$contrib >= 10), ]

clust4Anames = as.character(unique(c(pc1dat$name)))

mva_pca_set4 = clust4Anames

```

PCA is applied to Cluster 5. PC1 explains the majority of the input variance.
```{r}

mat1.2A = tmelt_1A[, c("Outcome", "Coefficient", "value")]
mat1.2A = mat1.2A %>% filter(Outcome %in% names5)

# Restructure the data frame

pca1.2A = mat1.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca1.2A_wide = pca1.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca1.2A_mat = as.matrix(pca1.2A_wide[, 2:4], nrow = nrow(pca1.2A_wide), ncol = 3)
rownames(pca1.2A_mat) = pca1.2A_wide$Outcome

pca1.2Ares = princomp(pca1.2A_mat, cor = TRUE, scores = TRUE)
summary(pca1.2Ares) # Component 1 should suffice

fviz_eig(pca1.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```

Cluster 5 primary explains MVA85A priming differences 8 weeks after BCG. Differences at the time of BCG also contribute.

```{r}
fviz_contrib(pca1.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

CD8 TNF and GrB Ki67 NK make large contributions and are selected as the Cluster 5 subset.
```{r}
fviz_contrib(pca1.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```


```{r}
contrib1.2A.1 = fviz_contrib(pca1.2Ares, axes = 1, choice = "ind")
#contrib1.2A.2 = fviz_contrib(pca1.2Ares, axes = 2, choice = "ind")

pc1dat = contrib1.2A.1$data[which(contrib1.2A.1$data$contrib >= 20), ]
#pc2dat = contrib1.2A.2$data[which(contrib1.2A.2$data$contrib >= 3), ]

clust5Anames = as.character(unique(c(pc1dat$name)))

mva_pca_set5 = clust5Anames

```

PCA is applied to Cluster 6. PC1 explains most variance in input data.

```{r}

mat1.2A = tmelt_1A[, c("Outcome", "Coefficient", "value")]
mat1.2A = mat1.2A %>% filter(Outcome %in% names6)

# Restructure the data frame

pca1.2A = mat1.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca1.2A_wide = pca1.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca1.2A_mat = as.matrix(pca1.2A_wide[, 2:4], nrow = nrow(pca1.2A_wide), ncol = 3)
rownames(pca1.2A_mat) = pca1.2A_wide$Outcome

pca1.2Ares = princomp(pca1.2A_mat, cor = TRUE, scores = TRUE)
summary(pca1.2Ares) # Component 1 should suffice

fviz_eig(pca1.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))
# Look at component 1

```
Cluster 6 explains MVA85A priming differences at the time of BCG and 1 year of age.

```{r}
fviz_contrib(pca1.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

Gr A Ki67 gd, CD4 totIFNg and GrA Ki67 NK make the largest contributions. They are selected to the Cluster 6 subset.
```{r}

fviz_contrib(pca1.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

```{r}
contrib1.2A.1 = fviz_contrib(pca1.2Ares, axes = 1, choice = "ind")

pc1dat = contrib1.2A.1$data[which(contrib1.2A.1$data$contrib >= 10), ]

clust6Anames = as.character(unique(c(pc1dat$name)))

mva_pca_set6 = clust6Anames

```

Collect all the MVA85A cluster subsets
```{r}
mvaclusters = c(mva_pca_set1, mva_pca_set2, mva_pca_set3, mva_pca_set4, mva_pca_set5, mva_pca_set6)

```

Assuming that the subsets are independent, we can perform corrections within cluster. Retrieve the fitted models by cluster.

```{r}

# Cluster 1 models

AM_C1.1 = glmmTMB(O20 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C1.1 = summary(AM_C1.1)

AM_C1.2 = glmmTMB(O27 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C1.2 = summary(AM_C1.2)

n1 = length(mva_pca_set1)
v1.1 = varA[20]
v1.2 = varA[27]

# Cluster 2 models

AM_C2.1 = glmmTMB(O4 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C2.1 = summary(AM_C2.1)

AM_C2.2 = glmmTMB(101 - O19 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_C2.2 = summary(AM_C2.2)

n2 = length(mva_pca_set2)

v2.1 = varA[4]
v2.2 = varA[19]

# Cluster 3 models

AM_C3.1 = glmmTMB(O30 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C3.1 = summary(AM_C3.1)

n3 = length(mva_pca_set3)

v3.1 = varA[30]

# Cluster 4 models

AM_C4.1 = glmmTMB(O17 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_C4.1 = summary(AM_C4.1)

AM_C4.2 = glmmTMB(O21 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_4.2 = summary(AM_C4.2)

n4 = length(mva_pca_set4)

v4.1 = varA[17]
v4.2 = varA[21]

# Cluster 5 models

AM_C5.1 = glmmTMB(O7 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_C5.1 = summary(AM_5.1)

AM_C5.2 = glmmTMB(101 - O37 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C5.2 = summary(AM_C5.2)

n5 = length(mva_pca_set5)

v5.1 = varA[7]
v5.2 = varA[37]

# Cluster 6 models

AM_C6.1 = glmmTMB(O3 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C6.1 = summary(AM_C6.1)

AM_C6.2 = glmmTMB(O31 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = poisson(link = "log"))
AS_C6.2 = summary(AM_C6.2)

AM_C6.3 = glmmTMB(101 - O36 ~ Treatment*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C6.3 = summary(AM_C6.3)

n6 = length(mva_pca_set6)

v6.1 = varA[3]
v6.2 = varA[31]
v6.3 = varA[36]

```

Create a contrast matrix for the predetermined pairwise comparisons.

```{r}

# Extract combinations of the levels

combinations = data.frame(emmeans(AM_C1.1, ~ Treatment * Time))
combination_names = paste(combinations$Treatment, combinations$Time, sep = "_")

# Define the list of contrasts

contrast_list = list(
  
  # Comparisons within Control
  
  "Control_T2_vs_T1" = setNames(c(1, 0, -1, 0, 0, 0), combination_names),
  "Control_T2_vs_T3" = setNames(c(1, 0, 0, 0, -1, 0), combination_names),
  "Control_T1_vs_T3" = setNames(c(0, 0, 1, 0, -1, 0), combination_names),
  
  # Comparisons within MVA85A
  
  "MVA85A_T2_vs_T1" = setNames(c(0, 1, 0, -1, 0, 0), combination_names),
  "MVA85A_T2_vs_T3" = setNames(c(0, 1, 0, 0, 0, -1), combination_names),
  "MVA85A_T1_vs_T3" = setNames(c(0, 0, 0, 1, 0, -1), combination_names),
  
  # Comparisons between Control and MVA85A
  
  "T2_Control_vs_MVA85A" = setNames(c(1, -1, 0, 0, 0, 0), combination_names),
  "T1_Control_vs_MVA85A" = setNames(c(0, 0, 1, -1, 0, 0), combination_names),
  "T3_Control_vs_MVA85A" = setNames(c(0, 0, 0, 0, 1, -1), combination_names)
)

contrast_list
```

Estimate and apply corrections for Cluster 1. Only significant differences within group over time.
```{r}

emmC1.1 = emmeans(AM_C1.1, ~ Treatment * Time)
emmC1.2 = emmeans(AM_C1.2, ~ Treatment * Time)

# Apply custom contrasts
contrastsC1.1 = data.frame(contrast(emmC1.1, method = contrast_list, adjust = "none"))
contrastsC1.2 = data.frame(contrast(emmC1.2, method = contrast_list, adjust = "none"))

contrastsC1.1$Outcome = v1.1
contrastsC1.2$Outcome = v1.2

clusterC1res = rbind(contrastsC1.1, contrastsC1.2)
clusterC1res = clusterC1res %>% arrange(p.value)

clusterC1res$BH = p.adjust(clusterC1res$p.value, method = "BH", n = length(clusterC1res$p.value))
clusterC1res$BY = p.adjust(clusterC1res$p.value, method = "BY", n = length(clusterC1res$p.value))

clusterC1res$expestimate = exp(clusterC1res$estimate)

clusterC1res %>% filter(BH < 0.06) %>% filter(Outcome == v1.1)

clusterC1res %>% filter(BH < 0.06) %>% filter(Outcome == v1.2)

```

Estimate and apply corrections for Cluster 2. There are only signicant differences over time in both groups.

```{r}

emmC2.1 = emmeans(AM_C2.1, ~ Treatment * Time)
emmC2.2 = emmeans(AM_C2.2, ~ Treatment * Time)

# Apply custom contrasts
contrastsC2.1 = data.frame(contrast(emmC2.1, method = contrast_list, adjust = "none"))
contrastsC2.2 = data.frame(contrast(emmC2.2, method = contrast_list, adjust = "none"))

contrastsC2.1$Outcome = v2.1
contrastsC2.2$Outcome = v2.2

clusterC2res = rbind(contrastsC2.1, contrastsC2.2)
clusterC2res = clusterC2res %>% arrange(p.value)

clusterC2res$BH = p.adjust(clusterC2res$p.value, method = "BH", n = length(clusterC2res$p.value))
clusterC2res$BY = p.adjust(clusterC2res$p.value, method = "BY", n = length(clusterC2res$p.value))

clusterC2res$expestimate = exp(clusterC2res$estimate)

clusterC2res %>% filter(BH < 0.06) %>% filter(Outcome == v2.1)

clusterC2res %>% filter(BH < 0.06) %>% filter(Outcome == v2.2)

```

Estimate and apply corrections for Cluster 3. There are only significant differences over time.

```{r}

emmC3.1 = emmeans(AM_C3.1, ~ Treatment * Time)

summary(AM_C3.1)

# Apply custom contrasts
contrastsC3.1 = data.frame(contrast(emmC3.1, method = contrast_list, adjust = "none"))

contrastsC3.1$Outcome = v3.1

clusterC3res = contrastsC3.1 %>% arrange(p.value)

clusterC3res$BH = p.adjust(clusterC3res$p.value, method = "BH", n = length(clusterC3res$p.value))
clusterC3res$BY = p.adjust(clusterC3res$p.value, method = "BY", n = length(clusterC3res$p.value))

clusterC3res$expestimate = exp(clusterC3res$estimate)

clusterC3res %>% filter(BH < 0.06) %>% filter(Outcome == v3.1)

```

Estimate and apply corrections for Cluster 4. There are only signicant differences over time in both groups.

```{r}

emmC4.1 = emmeans(AM_C4.1, ~ Treatment * Time)
emmC4.2 = emmeans(AM_C4.2, ~ Treatment * Time)

# Apply custom contrasts
contrastsC4.1 = data.frame(contrast(emmC4.1, method = contrast_list, adjust = "none"))
contrastsC4.2 = data.frame(contrast(emmC4.2, method = contrast_list, adjust = "none"))

contrastsC4.1$Outcome = v4.1
contrastsC4.2$Outcome = v4.2

clusterC4res = rbind(contrastsC4.1, contrastsC4.2)
clusterC4res = clusterC4res %>% arrange(p.value)

clusterC4res$BH = p.adjust(clusterC4res$p.value, method = "BH", n = length(clusterC4res$p.value))
clusterC4res$BY = p.adjust(clusterC4res$p.value, method = "BY", n = length(clusterC4res$p.value))

clusterC4res$expestimate = exp(clusterC4res$estimate)

clusterC4res %>% filter(BH < 0.06) %>% filter(Outcome == v4.1)

clusterC4res %>% filter(BH < 0.06) %>% filter(Outcome == v4.2)

```

Estimate and apply corrections for Cluster 4. There are only signicant differences over time in both groups.

```{r}

emmC4.1 = emmeans(AM_C4.1, ~ Treatment * Time)
emmC4.2 = emmeans(AM_C4.2, ~ Treatment * Time)

# Apply custom contrasts
contrastsC4.1 = data.frame(contrast(emmC4.1, method = contrast_list, adjust = "none"))
contrastsC4.2 = data.frame(contrast(emmC4.2, method = contrast_list, adjust = "none"))

contrastsC4.1$Outcome = v4.1
contrastsC4.2$Outcome = v4.2

clusterC4res = rbind(contrastsC4.1, contrastsC4.2)
clusterC4res = clusterC4res %>% arrange(p.value)

clusterC4res$BH = p.adjust(clusterC4res$p.value, method = "BH", n = length(clusterC4res$p.value))
clusterC4res$BY = p.adjust(clusterC4res$p.value, method = "BY", n = length(clusterC4res$p.value))

clusterC4res$expestimate = exp(clusterC4res$estimate)

clusterC4res %>% filter(BH < 0.06) %>% filter(Outcome == v4.1)

clusterC4res %>% filter(BH < 0.06) %>% filter(Outcome == v4.2)

```

Estimate and apply corrections for Cluster 5. We do find some group differences.

```{r}

emmC5.1 = emmeans(AM_C5.1, ~ Treatment * Time)
emmC5.2 = emmeans(AM_C5.2, ~ Treatment * Time)

# Apply custom contrasts
contrastsC5.1 = data.frame(contrast(emmC5.1, method = contrast_list, adjust = "none"))
contrastsC5.2 = data.frame(contrast(emmC5.2, method = contrast_list, adjust = "none"))

contrastsC5.1$Outcome = v5.1
contrastsC5.2$Outcome = v5.2

clusterC5res = rbind(contrastsC5.1, contrastsC5.2)
clusterC5res = clusterC5res %>% arrange(p.value)

clusterC5res$BH = p.adjust(clusterC5res$p.value, method = "BH", n = length(clusterC5res$p.value))
clusterC5res$BY = p.adjust(clusterC5res$p.value, method = "BY", n = length(clusterC5res$p.value))

clusterC5res$expestimate = exp(clusterC5res$estimate)

clusterC5res %>% filter(BH < 0.06) %>% filter(Outcome == v5.1)

clusterC5res %>% filter(BH < 0.06) %>% filter(Outcome == v5.2)

```

Estimate and apply corrections for Cluster 6. We only find differences over time.

```{r}

emmC6.1 = emmeans(AM_C6.1, ~ Treatment * Time)
emmC6.2 = emmeans(AM_C6.2, ~ Treatment * Time)
emmC6.3 = emmeans(AM_C6.3, ~ Treatment * Time)

# Apply custom contrasts
contrastsC6.1 = data.frame(contrast(emmC6.1, method = contrast_list, adjust = "none"))
contrastsC6.2 = data.frame(contrast(emmC6.2, method = contrast_list, adjust = "none"))
contrastsC6.3 = data.frame(contrast(emmC6.3, method = contrast_list, adjust = "none"))

contrastsC6.1$Outcome = v6.1
contrastsC6.2$Outcome = v6.2
contrastsC6.3$Outcome = v6.3

clusterC6res = rbind(contrastsC6.1, contrastsC6.2, contrastsC6.3)
clusterC6res = clusterC6res %>% arrange(p.value)

clusterC6res$BH = p.adjust(clusterC6res$p.value, method = "BH", n = length(clusterC6res$p.value))
clusterC6res$BY = p.adjust(clusterC6res$p.value, method = "BY", n = length(clusterC6res$p.value))

clusterC6res$expestimate = exp(clusterC6res$estimate)

clusterC6res %>% filter(BH < 0.06) %>% filter(Outcome == v6.1)

clusterC6res %>% filter(BH < 0.06) %>% filter(Outcome == v6.2)

clusterC6res %>% filter(BH < 0.06) %>% filter(Outcome == v6.3)

```
Perform a PCA on Cluster 1 in Group B. PC1 explains the majority of the variance in the input data.

```{r}

mat1.2B = tmelt_1B[, c("Outcome", "Coefficient", "value")]
mat1.2B = mat1.2B %>% filter(Outcome %in% names1B)

# Restructure the data frame

pca1.2B = mat1.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca1.2B_wide = pca1.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca1.2B_mat = as.matrix(pca1.2B_wide[, 2:3], nrow = nrow(pca1.2B_wide), ncol = 2)
rownames(pca1.2B_mat) = pca1.2B_wide$Outcome

pca1.2Bres = princomp(pca1.2B_mat, cor = TRUE, scores = TRUE)
summary(pca1.2Bres) # Component 1 should suffice

fviz_eig(pca1.2Bres, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```


Cluster 1 explains MVA85A priming differences at the time of BCG and 1 week later.

```{r}
fviz_contrib(pca1.2Bres, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

HLA-DR CD4 makes the largest contribution. It is selected to the Cluster 1 subset.
```{r}

fviz_contrib(pca1.2Bres, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

```{r}
contrib1.2B.1 = fviz_contrib(pca1.2Bres, axes = 1, choice = "ind")

pc1dat = contrib1.2B.1$data[which(contrib1.2B.1$data$contrib >= 20), ]

clust1Bnames = as.character(unique(c(pc1dat$name)))

mva_pca_set1B = clust1Bnames

```


Perform a PCA on Cluster 2 in Group B. Both PC1 and PC2 should be retained.

```{r}

mat1.2B = tmelt_1B[, c("Outcome", "Coefficient", "value")]
mat1.2B = mat1.2B %>% filter(Outcome %in% names2B)

# Restructure the data frame

pca1.2B = mat1.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca1.2B_wide = pca1.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca1.2B_mat = as.matrix(pca1.2B_wide[, 2:3], nrow = nrow(pca1.2B_wide), ncol = 2)
rownames(pca1.2B_mat) = pca1.2B_wide$Outcome

pca1.2Bres = princomp(pca1.2B_mat, cor = TRUE, scores = TRUE)
summary(pca1.2Bres) # Component 1 should suffice

fviz_eig(pca1.2Bres, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```


PC1 and PC2 explain MVA85A priming differences at the time of BCG and 1 week later.

```{r}
fviz_contrib(pca1.2Bres, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca1.2Bres, axes = 2, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

CD14 Mono makes the largest contribution to PC1. CD3, CD8, CD16 make the biggest contributions to PC2. They are selected to the Cluster 2 subset.
```{r}

fviz_contrib(pca1.2Bres, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca1.2Bres, axes = 2, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

```{r}
contrib1.2B.1 = fviz_contrib(pca1.2Bres, axes = 1, choice = "ind")

pc1dat = contrib1.2B.1$data[which(contrib1.2B.1$data$contrib >= 20), ]

contrib1.2B.2 = fviz_contrib(pca1.2Bres, axes = 2, choice = "ind")

pc2dat = contrib1.2B.2$data[which(contrib1.2B.2$data$contrib >= 20), ]

clust2Bnames = as.character(unique(c(pc1dat$name, pc2dat$name)))

mva_pca_set2B = clust2Bnames

```


Assuming that the subsets are independent, we can perform corrections within cluster. Retrieve the fitted models by cluster.

```{r}

# Cluster 1 models

BM_C1.1 = glmmTMB(O16 ~ Treatment*Time + Gender*Time + (Time| ID), data = groupB2, family = Gamma(link = "log"))
BS_C1.1 = summary(BM_C1.1)

n1B = length(mva_pca_set1B)
v1.1 = varB[16]

# Cluster 2 models

BM_C2.1 = glmmTMB(O9 ~ Treatment*Time + Gender*Time + (1| ID), data = groupB2, family = tweedie(link = "log"))
BS_C2.1 = summary(BM_C2.1)

BM_C2.2 = glmmTMB(O8 ~ Treatment*Time + Gender*Time + (1| ID), data = groupB2, family = nbinom1(link = "log"))
BS_C2.2 = summary(BM_C2.2)

BM_C2.3 = glmmTMB(O11 ~ Treatment*Time + Gender*Time + (1| ID), data = groupB2, family = poisson(link = "log"))
BS_C2.3 = summary(BM_C2.3)

BM_C2.4 = glmmTMB(O8 ~ Treatment*Time + Gender*Time + (1| ID), data = groupB2, family = nbinom1(link = "log"))
BS_C2.4 = summary(BM_C2.4)

n2 = length(mva_pca_set2B)

v2.1 = varB[9]
v2.2 = varB[8]
v2.3 = varB[11]
v2.4 = varB[13]


```


Create a contrast matrix for the predetermined pairwise comparisons.

```{r}

# Extract combinations of the levels

combinations = data.frame(emmeans(BM_C1.1, ~ Treatment * Time))
combination_names = paste(combinations$Treatment, combinations$Time, sep = "_")

# Define the list of contrasts

contrast_list = list(
  
  # Comparisons within Control
  
  "Control_T2_vs_T1" = setNames(c(1, 0, -1, 0), combination_names),
  
  # Comparisons within MVA85A
  
  "MVA85A_T2_vs_T1" = setNames(c(0, 1, 0, -1), combination_names),
  
  # Comparisons between Control and MVA85A
  
  "T2_Control_vs_MVA85A" = setNames(c(1, -1, 0, 0), combination_names),
  "T1_Control_vs_MVA85A" = setNames(c(0, 0, 1, -1), combination_names)
)

contrast_list
```

Estimate and apply corrections for Cluster 6. We find no differences.

```{r}

emmC1.1 = emmeans(BM_C1.1, ~ Treatment * Time)

# Apply custom contrasts
contrastsC1.1 = data.frame(contrast(emmC1.1, method = contrast_list, adjust = "none"))

contrastsC1.1$Outcome = v1.1

clusterC1res = contrastsC1.1 %>% arrange(p.value)

clusterC1res$BH = p.adjust(clusterC1res$p.value, method = "BH", n = length(clusterC1res$p.value))
clusterC1res$BY = p.adjust(clusterC1res$p.value, method = "BY", n = length(clusterC1res$p.value))

clusterC1res$expestimate = exp(clusterC1res$estimate)

clusterC1res %>% filter(BH < 0.06) %>% filter(Outcome == v1.1)

```

Estimate and apply corrections for Cluster 2. We find no differences.

```{r}

emmC2.1 = emmeans(BM_C2.1, ~ Treatment * Time)
emmC2.2 = emmeans(BM_C2.2, ~ Treatment * Time)
emmC2.3 = emmeans(BM_C2.3, ~ Treatment * Time)
emmC2.4 = emmeans(BM_C2.4, ~ Treatment * Time)

# Apply custom contrasts
contrastsC2.1 = data.frame(contrast(emmC2.1, method = contrast_list, adjust = "none"))
contrastsC2.2 = data.frame(contrast(emmC2.2, method = contrast_list, adjust = "none"))
contrastsC2.3 = data.frame(contrast(emmC2.3, method = contrast_list, adjust = "none"))
contrastsC2.4 = data.frame(contrast(emmC2.4, method = contrast_list, adjust = "none"))

contrastsC2.1$Outcome = v2.1
contrastsC2.2$Outcome = v2.2
contrastsC2.3$Outcome = v2.3
contrastsC2.4$Outcome = v2.4

clusterC2res = rbind(contrastsC2.1, contrastsC2.2, contrastsC2.3, contrastsC2.4)
clusterC2res = clusterC2res %>% arrange(p.value)

clusterC2res$BH = p.adjust(clusterC2res$p.value, method = "BH", n = length(clusterC2res$p.value))
clusterC2res$BY = p.adjust(clusterC2res$p.value, method = "BY", n = length(clusterC2res$p.value))

clusterC2res$expestimate = exp(clusterC2res$estimate)

clusterC2res %>% filter(BH < 0.06) %>% filter(Outcome == v2.1)

clusterC2res %>% filter(BH < 0.06) %>% filter(Outcome == v2.2)

clusterC2res %>% filter(BH < 0.06) %>% filter(Outcome == v2.3)

clusterC2res %>% filter(BH < 0.06) %>% filter(Outcome == v2.4)

```

# QFT

```{r}

mat2.2A = tmelt_2A[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

mat2.2A = mat2.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

mat2.2A_wide = mat2.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

mat2.2A = as.matrix(mat2.2A_wide[, 2:4], nrow = nrow(mat2.2A_wide), ncol = 3)
row.names(mat2.2A) = mat2.2A_wide$Outcome
dist2.2A = get_dist(mat2.2A, "pearson")

mat2.2B = tmelt_2B[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

mat2.2B = mat2.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

mat2.2B_wide = mat2.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

mat2.2B = as.matrix(mat2.2B_wide[, 2:3], nrow = nrow(mat2.2B_wide), ncol = 2)
row.names(mat2.2B) = mat2.2B_wide$Outcome
dist2.2B = get_dist(mat2.2B, "pearson")
```

```{r}

res2.2.hclustA = as.hclust(agnes(dist2.2A, diss = TRUE, method = "average"))
res2.2.hclustB = as.hclust(agnes(dist2.2B, diss = TRUE, method = "average"))
```

There are effectively 7 groups. There are 2 singletons.
```{r}

hcdata2.2A = dendro_data_k(res2.2.hclustA, 7)

p = plot_ggdendro(hcdata2.2A,
                  scale.color = cols,
                   direction   = "rl",
                   expand.y    = 0.2) 
p + ylab("\n Link Height") + geom_hline(yintercept = 0.15, linetype = "solid", size = 1) + theme_bw() +
  theme(axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
        axis.title.y = element_blank(),
        axis.text.x = element_text(size = 10, family = "Arial"),
        axis.text.y = element_text(size = 10, family = "Arial"))
  
hcdata2.2B = dendro_data_k(res2.2.hclustB, 2)

p = plot_ggdendro(hcdata2.2B,
                  scale.color = c("darkblue", "darkgreen"),
                   direction   = "rl",
                   expand.y    = 0.2) 
p + ylab("\n Link Height") + geom_hline(yintercept = 0.15, linetype = "solid", size = 1) + theme_bw() +
  theme(axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
        axis.title.y = element_blank(),
        axis.text.x = element_text(size = 10, family = "Arial"),
        axis.text.y = element_text(size = 10, family = "Arial"))

```

```{r}

clusters2.2A = cutree(res2.2.hclustA, k=7)


names7 = names(clusters2.2A[clusters2.2A == 1])
names5 = names(clusters2.2A[clusters2.2A == 2])
names6 = names(clusters2.2A[clusters2.2A == 3])
names3 = names(clusters2.2A[clusters2.2A == 4])
names2 = names(clusters2.2A[clusters2.2A == 5])
names1 = names(clusters2.2A[clusters2.2A == 6])
names4 = names(clusters2.2A[clusters2.2A == 7])

clusters2.2B = cutree(res2.2.hclustB, k=2)

names2B = names(clusters2.2B[clusters2.2B == 1])
names1B = names(clusters2.2B[clusters2.2B == 2])

```

No need to perform a PCA on Cluster 1 or Cluster 2.

```{r}
qft_pca_set1 = names1
qft_pca_set2 = names2
qft_pca_set4 = names4
```

Perform a PCA on Cluster 3. Retain 2 PCs.
```{r}

mat2.2A = tmelt_2A[, c("Outcome", "Coefficient", "value")]
mat2.2A = mat2.2A %>% filter(Outcome %in% names3)

# Restructure the data frame

pca2.2A = mat2.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca2.2A_wide = pca2.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca2.2A_mat = as.matrix(pca2.2A_wide[, 2:4], nrow = nrow(pca2.2A_wide), ncol = 3)
rownames(pca2.2A_mat) = pca2.2A_wide$Outcome

pca2.2Ares = princomp(pca2.2A_mat, cor = TRUE, scores = TRUE)
summary(pca2.2Ares) # Component 1 should suffice

fviz_eig(pca2.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

# Look at component 1 & 2

```

The first PC explains variance in Day365 and Day56. The second PC explains variance at Day 112.
```{r}
fviz_contrib(pca2.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca2.2Ares, axes = 2, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

Bulk CD8 R7-RA+ and Bulk CD4 R7-RA- have a large contribution to both PCs. GrB Ki67 CD4 and GrB Ki67 NK have large contributions to PC2.
```{r}
fviz_contrib(pca2.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca2.2Ares, axes = 2, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

```{r}
contrib2.2A.1 = fviz_contrib(pca2.2Ares, axes = 1, choice = "ind")
contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib2.2A.1$data[which(contrib2.2A.1$data$contrib >= 15), ]
pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 15), ]

pcnames1 = as.character(unique(c(pc1dat$name, pc2dat$name)))

qft_pca_set3 = pcnames1

```

Perform a PCA on Cluster 5. PC1 is sufficient.
```{r}

mat2.2A = tmelt_2A[, c("Outcome", "Coefficient", "value")]
mat2.2A = mat2.2A %>% filter(Outcome %in% names5)

# Restructure the data frame

pca2.2A = mat2.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca2.2A_wide = pca2.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca2.2A_mat = as.matrix(pca2.2A_wide[, 2:4], nrow = nrow(pca2.2A_wide), ncol = 3)
rownames(pca2.2A_mat) = pca2.2A_wide$Outcome

pca2.2Ares = princomp(pca2.2A_mat, cor = TRUE, scores = TRUE)
summary(pca2.2Ares) # Component 1 should suffice

fviz_eig(pca2.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))
# Look at component 1 & 2

```
PC1 explains variance at all time points.

```{r}
fviz_contrib(pca2.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

GrK Ki67 CD4 is the only immune outcome making a large contribution.

```{r}
fviz_contrib(pca2.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

```{r}
contrib2.2A.1 = fviz_contrib(pca2.2Ares, axes = 1, choice = "ind")
#contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib2.2A.1$data[which(contrib2.2A.1$data$contrib >= 30), ]
#pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 20), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

qft_pca_set5 = pcnames1

```

Perform PCA on Cluster 6. PC1 is sufficient.
```{r}

mat2.2A = tmelt_2A[, c("Outcome", "Coefficient", "value")]
mat2.2A = mat2.2A %>% filter(Outcome %in% names6)

# Restructure the data frame

pca2.2A = mat2.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca2.2A_wide = pca2.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca2.2A_mat = as.matrix(pca2.2A_wide[, 2:4], nrow = nrow(pca2.2A_wide), ncol = 3)
rownames(pca2.2A_mat) = pca2.2A_wide$Outcome

pca2.2Ares = princomp(pca2.2A_mat, cor = TRUE, scores = TRUE)
summary(pca2.2Ares) # Component 1 should suffice

fviz_eig(pca2.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```
PC1 primarily explains variance at Day 56.
```{r}
fviz_contrib(pca2.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```
There are 7 immune outcomes making larger than uniform contributions to PC1.

```{r}
fviz_contrib(pca2.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

```{r}
contrib2.2A.1 = fviz_contrib(pca2.2Ares, axes = 1, choice = "ind")
#contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib2.2A.1$data[which(contrib2.2A.1$data$contrib >= 5), ]
#pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 20), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

qft_pca_set6 = pcnames1

```

Perform PCA on Cluster 7. PC1 and PC2 are sufficient.
```{r}

mat2.2A = tmelt_2A[, c("Outcome", "Coefficient", "value")]
mat2.2A = mat2.2A %>% filter(Outcome %in% names7)

# Restructure the data frame

pca2.2A = mat2.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca2.2A_wide = pca2.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca2.2A_mat = as.matrix(pca2.2A_wide[, 2:4], nrow = nrow(pca2.2A_wide), ncol = 3)
rownames(pca2.2A_mat) = pca2.2A_wide$Outcome

pca2.2Ares = princomp(pca2.2A_mat, cor = TRUE, scores = TRUE)
summary(pca2.2Ares) # Component 1 should suffice

fviz_eig(pca2.2Ares, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```

PC1 explains Day 365 and Day 112. PC2 explains Day 56.
```{r}
fviz_contrib(pca2.2Ares, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca2.2Ares, axes = 2, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

There are 3 different immune outcomes selected for the cluster.

```{r}
fviz_contrib(pca2.2Ares, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca2.2Ares, axes = 2, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

```{r}
contrib2.2A.1 = fviz_contrib(pca2.2Ares, axes = 1, choice = "ind")
contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib2.2A.1$data[which(contrib2.2A.1$data$contrib >= 10), ]
pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 10), ]

pcnames1 = as.character(unique(c(pc1dat$name, pc2dat$name)))

qft_pca_set7 = pcnames1

```

```{r}
qftclusters = c(qft_pca_set1, qft_pca_set2, qft_pca_set3, qft_pca_set4, qft_pca_set5, qft_pca_set6, qft_pca_set7)
```

Assuming that the subsets are independent, we can perform corrections within cluster. Retrieve the fitted models by cluster.

```{r}

# Cluster 1 models

AM_C1.1 = glmmTMB(O26 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = nbinom1(link = "log"))

n1 = length(qft_pca_set1)
v1.1 = varA[26]

# Cluster 2 models

AM_C2.1 = glmmTMB(O16 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_C2.1 = summary(AM_C2.1)

AM_C2.2 = glmmTMB(O21 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_C2.2 = summary(AM_C2.2)

n2 = length(qft_pca_set2)

v2.1 = varA[16]
v2.2 = varA[21]

# Cluster 3 models

AM_C3.1 = glmmTMB(O17 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_C3.1 = summary(AM_C3.1)

AM_C3.2 = glmmTMB(O18 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = Gamma(link = "log"))
AS_C3.2 = summary(AM_C3.2)

AM_C3.3 = glmmTMB(101 - O37 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C3.3 = summary(AM_C3.3)

AM_C3.4 = glmmTMB(O27 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C3.4 = summary(AM_C3.4)

n3 = length(qft_pca_set3)

v3.1 = varA[17]
v3.2 = varA[18]
v3.3 = varA[37]
v3.4 = varA[27]

# Cluster 4 models

AM_C4.1 = glmmTMB(O39 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C4.1 = summary(AM_C4.1)

n4 = length(qft_pca_set4)

v4.1 = varA[39]

# Cluster 5 models

AM_C5.1 = glmmTMB(O29 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C5.1 = summary(AM_5.1)

n5 = length(qft_pca_set5)

v5.1 = varA[29]

# Cluster 6 models

AM_C6.1 = glmmTMB(O23 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C6.1 = summary(AM_C6.1)

AM_C6.2 =glmmTMB(O8 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C6.2 = summary(AM_C6.2)

AM_C6.3 = glmmTMB(O24 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C6.3 = summary(AM_C6.3)

AM_C6.4 = glmmTMB(O34 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C6.4 = summary(AM_C6.4)

AM_C6.5 = glmmTMB(O25 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C6.5 = summary(AM_C6.5)

AM_C6.6 = glmmTMB(94-O15 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C6.6 = summary(AM_C6.6)

AM_C6.7 = glmmTMB(101 - O36 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C6.7 = summary(AM_C6.7)

n6 = length(qft_pca_set6)

v6.1 = varA[23]
v6.2 = varA[8]
v6.3 = varA[24]
v6.4 = varA[34]
v6.5 = varA[25]
v6.6 = varA[15]
v6.7 = varA[36]

# Cluster 7 models

AM_C7.1 = glmmTMB(O3 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C7.1 = summary(AM_C7.1)

AM_C7.2 = glmmTMB(O5 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C7.2 = summary(AM_C7.2)

AM_C7.3 = glmmTMB(O20 ~ QFT*Time + Gender*Time + (1| ID), data = groupA, family = tweedie(link = "log"))
AS_C7.3 = summary(AM_C7.3)

n7 = length(qft_pca_set7)

v7.1 = varA[3]
v7.2 = varA[5]
v7.3 = varA[20]

```

Create a contrast matrix for the predetermined pairwise comparisons.

```{r}

# Extract combinations of the levels

combinations = data.frame(emmeans(AM_C1.1, ~ QFT * Time))
combination_names = paste(combinations$QFT, combinations$Time, sep = "_")

# Define the list of contrasts

contrast_list = list(
  
  # Comparisons within Negative
  
  "Negative_T2_vs_T1" = setNames(c(1, 0, -1, 0, 0, 0), combination_names),
  "Negative_T2_vs_T3" = setNames(c(1, 0, 0, 0, -1, 0), combination_names),
  "Negative_T1_vs_T3" = setNames(c(0, 0, 1, 0, -1, 0), combination_names),
  
  # Comparisons within Positive
  
  "Positive_T2_vs_T1" = setNames(c(0, 1, 0, -1, 0, 0), combination_names),
  "Positive_T2_vs_T3" = setNames(c(0, 1, 0, 0, 0, -1), combination_names),
  "Positive_T1_vs_T3" = setNames(c(0, 0, 0, 1, 0, -1), combination_names),
  
  # Comparisons between Negative and Positive
  
  "T2_Negative_vs_Positive" = setNames(c(1, -1, 0, 0, 0, 0), combination_names),
  "T1_Negative_vs_Positive" = setNames(c(0, 0, 1, -1, 0, 0), combination_names),
  "T3_Negative_vs_Positive" = setNames(c(0, 0, 0, 0, 1, -1), combination_names)
)

contrast_list
```

Estimate and apply corrections for Cluster 1. Only significant differences within group over time.
```{r}

emmC1.1 = emmeans(AM_C1.1, ~ QFT * Time)

# Apply custom contrasts
contrastsC1.1 = data.frame(contrast(emmC1.1, method = contrast_list, adjust = "none"))

contrastsC1.1$Outcome = v1.1

clusterC1res = contrastsC1.1 %>% arrange(p.value)

clusterC1res$BH = p.adjust(clusterC1res$p.value, method = "BH", n = length(clusterC1res$p.value))
clusterC1res$BY = p.adjust(clusterC1res$p.value, method = "BY", n = length(clusterC1res$p.value))

clusterC1res$expestimate = exp(clusterC1res$estimate)

clusterC1res %>% filter(BH < 0.06) %>% filter(Outcome == v1.1)

```

Estimate and apply corrections for Cluster 2. There are only signicant differences over time in both groups.

```{r}

emmC2.1 = emmeans(AM_C2.1, ~ QFT * Time)
emmC2.2 = emmeans(AM_C2.2, ~ QFT * Time)

# Apply custom contrasts
contrastsC2.1 = data.frame(contrast(emmC2.1, method = contrast_list, adjust = "none"))
contrastsC2.2 = data.frame(contrast(emmC2.2, method = contrast_list, adjust = "none"))

contrastsC2.1$Outcome = v2.1
contrastsC2.2$Outcome = v2.2

clusterC2res = rbind(contrastsC2.1, contrastsC2.2)
clusterC2res = clusterC2res %>% arrange(p.value)

clusterC2res$BH = p.adjust(clusterC2res$p.value, method = "BH", n = length(clusterC2res$p.value))
clusterC2res$BY = p.adjust(clusterC2res$p.value, method = "BY", n = length(clusterC2res$p.value))

clusterC2res$expestimate = exp(clusterC2res$estimate)

clusterC2res %>% filter(BH < 0.06) %>% filter(Outcome == v2.1)

clusterC2res %>% filter(BH < 0.06) %>% filter(Outcome == v2.2)

```

Estimate and apply corrections for Cluster 3. There are only signicant differences over time in both groups.

```{r}

emmC3.1 = emmeans(AM_C3.1, ~ QFT * Time)
emmC3.2 = emmeans(AM_C3.2, ~ QFT * Time)
emmC3.3 = emmeans(AM_C3.3, ~ QFT * Time)
emmC3.4 = emmeans(AM_C3.4, ~ QFT * Time)

# Apply custom contrasts
contrastsC3.1 = data.frame(contrast(emmC3.1, method = contrast_list, adjust = "none"))
contrastsC3.2 = data.frame(contrast(emmC3.2, method = contrast_list, adjust = "none"))
contrastsC3.3 = data.frame(contrast(emmC3.3, method = contrast_list, adjust = "none"))
contrastsC3.4 = data.frame(contrast(emmC3.4, method = contrast_list, adjust = "none"))

contrastsC3.1$Outcome = v3.1
contrastsC3.2$Outcome = v3.2
contrastsC3.3$Outcome = v3.3
contrastsC3.4$Outcome = v3.4

clusterC3res = rbind(contrastsC3.1, contrastsC3.2, contrastsC3.3, contrastsC3.4)
clusterC3res = clusterC3res %>% arrange(p.value)

clusterC3res$BH = p.adjust(clusterC3res$p.value, method = "BH", n = length(clusterC3res$p.value))
clusterC3res$BY = p.adjust(clusterC3res$p.value, method = "BY", n = length(clusterC3res$p.value))

clusterC3res$expestimate = exp(clusterC3res$estimate)

clusterC3res %>% filter(BH < 0.06) %>% filter(Outcome == v3.1)

clusterC3res %>% filter(BH < 0.06) %>% filter(Outcome == v3.2)

clusterC3res %>% filter(BH < 0.06) %>% filter(Outcome == v3.3)

clusterC3res %>% filter(BH < 0.06) %>% filter(Outcome == v3.4)

```

Estimate and apply corrections for Cluster 4. There are only signicant differences over time in both groups.

```{r}

qft_pca_set4
emmC4.1 = emmeans(AM_C4.1, ~ QFT * Time)

# Apply custom contrasts
contrastsC4.1 = data.frame(contrast(emmC4.1, method = contrast_list, adjust = "none"))

contrastsC4.1$Outcome = v4.1

clusterC4res = contrastsC4.1 %>% arrange(p.value)

clusterC4res$BH = p.adjust(clusterC4res$p.value, method = "BH", n = length(clusterC4res$p.value))
clusterC4res$BY = p.adjust(clusterC4res$p.value, method = "BY", n = length(clusterC4res$p.value))

clusterC4res$expestimate = exp(clusterC4res$estimate)

clusterC4res %>% filter(BH < 0.06) %>% filter(Outcome == v4.1)


```

Estimate and apply corrections for Cluster 5. There are signicant differences over time in both groups and between groups.

```{r}

emmC5.1 = emmeans(AM_C5.1, ~ QFT * Time)

# Apply custom contrasts
contrastsC5.1 = data.frame(contrast(emmC5.1, method = contrast_list, adjust = "none"))

contrastsC5.1$Outcome = v5.1

clusterC5res = contrastsC5.1 %>% arrange(p.value)

clusterC5res$BH = p.adjust(clusterC5res$p.value, method = "BH", n = length(clusterC5res$p.value))
clusterC5res$BY = p.adjust(clusterC5res$p.value, method = "BY", n = length(clusterC5res$p.value))

clusterC5res$expestimate = exp(clusterC5res$estimate)

clusterC5res %>% filter(BH < 0.06) %>% filter(Outcome == v5.1)


```

Estimate and apply corrections for Cluster 6. There are significant differences over time in both groups. For gd %Ki67+, there is only a difference over time in the positive group. There is a difference between groups at the time of BCG for NK %Ki67+.

```{r}

emmC6.1 = emmeans(AM_C6.1, ~ QFT * Time)
emmC6.2 = emmeans(AM_C6.2, ~ QFT * Time)
emmC6.3 = emmeans(AM_C6.3, ~ QFT * Time)
emmC6.4 = emmeans(AM_C6.4, ~ QFT * Time)
emmC6.5 = emmeans(AM_C6.5, ~ QFT * Time)
emmC6.6 = emmeans(AM_C6.6, ~ QFT * Time)
emmC6.7 = emmeans(AM_C6.7, ~ QFT * Time)

# Apply custom contrasts
contrastsC6.1 = data.frame(contrast(emmC6.1, method = contrast_list, adjust = "none"))
contrastsC6.2 = data.frame(contrast(emmC6.2, method = contrast_list, adjust = "none"))
contrastsC6.3 = data.frame(contrast(emmC6.3, method = contrast_list, adjust = "none"))
contrastsC6.4 = data.frame(contrast(emmC6.4, method = contrast_list, adjust = "none"))
contrastsC6.5 = data.frame(contrast(emmC6.5, method = contrast_list, adjust = "none"))
contrastsC6.6 = data.frame(contrast(emmC6.6, method = contrast_list, adjust = "none"))
contrastsC6.7 = data.frame(contrast(emmC6.7, method = contrast_list, adjust = "none"))

contrastsC6.1$Outcome = v6.1
contrastsC6.2$Outcome = v6.2
contrastsC6.3$Outcome = v6.3
contrastsC6.4$Outcome = v6.4
contrastsC6.5$Outcome = v6.5
contrastsC6.6$Outcome = v6.6
contrastsC6.7$Outcome = v6.7

clusterC6res = rbind(contrastsC6.1, contrastsC6.2, contrastsC6.3, contrastsC6.4, contrastsC6.5, contrastsC6.6, contrastsC6.7)
clusterC6res = clusterC6res %>% arrange(p.value)

clusterC6res$BH = p.adjust(clusterC6res$p.value, method = "BH", n = length(clusterC6res$p.value))
clusterC6res$BY = p.adjust(clusterC6res$p.value, method = "BY", n = length(clusterC6res$p.value))

clusterC6res$expestimate = exp(clusterC6res$estimate)

clusterC6res %>% filter(BH < 0.06) %>% filter(Outcome == v6.1)

clusterC6res %>% filter(BH < 0.06) %>% filter(Outcome == v6.2)

clusterC6res %>% filter(BH < 0.06) %>% filter(Outcome == v6.3)

clusterC6res %>% filter(BH < 0.06) %>% filter(Outcome == v6.4)

clusterC6res %>% filter(BH < 0.06) %>% filter(Outcome == v6.5)

clusterC6res %>% filter(BH < 0.06) %>% filter(Outcome == v6.6)

clusterC6res %>% filter(BH < 0.06) %>% filter(Outcome == v6.7)


```

Estimate and apply corrections for Cluster 7. There are significant differences over time in both groups. 
```{r}

emmC7.1 = emmeans(AM_C7.1, ~ QFT * Time)
emmC7.2 = emmeans(AM_C7.2, ~ QFT * Time)
emmC7.3 = emmeans(AM_C7.3, ~ QFT * Time)


# Apply custom contrasts
contrastsC7.1 = data.frame(contrast(emmC7.1, method = contrast_list, adjust = "none"))
contrastsC7.2 = data.frame(contrast(emmC7.2, method = contrast_list, adjust = "none"))
contrastsC7.3 = data.frame(contrast(emmC7.3, method = contrast_list, adjust = "none"))


contrastsC7.1$Outcome = v7.1
contrastsC7.2$Outcome = v7.2
contrastsC7.3$Outcome = v7.3


clusterC7res = rbind(contrastsC7.1, contrastsC7.2, contrastsC7.3)
clusterC7res = clusterC7res %>% arrange(p.value)

clusterC7res$BH = p.adjust(clusterC7res$p.value, method = "BH", n = length(clusterC7res$p.value))
clusterC7res$BY = p.adjust(clusterC7res$p.value, method = "BY", n = length(clusterC7res$p.value))

clusterC7res$expestimate = exp(clusterC7res$estimate)

clusterC7res %>% filter(BH < 0.06) %>% filter(Outcome == v7.1)

clusterC7res %>% filter(BH < 0.06) %>% filter(Outcome == v7.2)

clusterC7res %>% filter(BH < 0.06) %>% filter(Outcome == v7.3)


```

Perform a PCA on Cluster 1 in Group B. Both PCs are required.

```{r}

mat2.2B = tmelt_2B[, c("Outcome", "Coefficient", "value")]
mat2.2B = mat2.2B %>% filter(Outcome %in% names1B)

# Restructure the data frame

pca2.2B = mat2.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca2.2B_wide = pca2.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca2.2B_mat = as.matrix(pca2.2B_wide[, 2:3], nrow = nrow(pca2.2B_wide), ncol = 2)
rownames(pca2.2B_mat) = pca2.2B_wide$Outcome

pca2.2Bres = princomp(pca2.2B_mat, cor = TRUE, scores = TRUE)
summary(pca2.2Bres) # Component 1 should suffice

fviz_eig(pca2.2Bres, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```


Cluster 1 explains MVA85A priming differences at the time of BCG and 1 week later.

```{r}
fviz_contrib(pca2.2Bres, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca2.2Bres, axes = 2, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

CD16, HLA-DR CD8 and CD8 makes the largest contribution to PC1. HLA-DR gd and gd TCR make the largest contribution to PC2. They are selected to the Cluster 1 subset.
```{r}

fviz_contrib(pca2.2Bres, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca2.2Bres, axes = 2, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))
```

```{r}
contrib2.2B.1 = fviz_contrib(pca2.2Bres, axes = 1, choice = "ind")
contrib2.2B.2 = fviz_contrib(pca2.2Bres, axes = 2, choice = "ind")

pc1dat = contrib2.2B.1$data[which(contrib2.2B.1$data$contrib >= 15), ]
pc2dat = contrib2.2B.2$data[which(contrib2.2B.2$data$contrib >= 15), ]

clust1Bnames = as.character(unique(c(pc1dat$name, pc2dat$name)))

qft_pca_set1B = clust1Bnames

```


Perform a PCA on Cluster 2 in Group B. PC1 should be retained.

```{r}

mat2.2B = tmelt_2B[, c("Outcome", "Coefficient", "value")]
mat2.2B = mat2.2B %>% filter(Outcome %in% names2B)

# Restructure the data frame

pca2.2B = mat2.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca2.2B_wide = pca2.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca2.2B_mat = as.matrix(pca2.2B_wide[, 2:3], nrow = nrow(pca2.2B_wide), ncol = 2)
rownames(pca2.2B_mat) = pca2.2B_wide$Outcome

pca2.2Bres = princomp(pca2.2B_mat, cor = TRUE, scores = TRUE)
summary(pca2.2Bres) # Component 1 should suffice

fviz_eig(pca2.2Bres, addlabels = TRUE, barfill = "darkgrey", barcolor = "black", bar_width = 0.5,
         xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "",
         ylim = c(0, 100)) + theme_minimal() +
theme(axis.title.y = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
                                   axis.text.x = element_text(size = 10, family = "Arial"),
                                   axis.text.y = element_text(size = 10, family = "Arial"))

```


PC1 explains QFT differences at the time of BCG and 1 week later.

```{r}
fviz_contrib(pca2.2Bres, axes = 1, choice = "var", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```
CD19 and CD3 makes the largest contribution to PC1. They are selected to the Cluster 2 subset.
```{r}

fviz_contrib(pca2.2Bres, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```

```{r}
contrib2.2B.1 = fviz_contrib(pca2.2Bres, axes = 1, choice = "ind")

pc1dat = contrib2.2B.1$data[which(contrib2.2B.1$data$contrib >= 20), ]

clust1Bnames = as.character(unique(c(pc1dat$name)))

qft_pca_set2B = clust1Bnames

```

Assuming that the subsets are independent, we can perform corrections within cluster. Retrieve the fitted models by cluster.

```{r}

# Cluster 1 models

BM_C1.1 = glmmTMB(O8 ~ QFT*Time + Gender*Time + (1| ID), data = groupB2, family = nbinom1(link = "log"))
BM_C1.2 = glmmTMB(O13 ~ QFT*Time + Gender*Time + (1| ID), data = groupB2, family = poisson(link = "log"))
BM_C1.3 = glmmTMB(O14 ~ QFT*Time + Gender*Time + (Time| ID), data = groupB2, family = t_family(link = "log"))
BM_C1.4 = glmmTMB(O17 ~ QFT*Time + Gender*Time + (1| ID), data = groupB2, family = tweedie(link = "log"))
BM_C1.5 = glmmTMB(O18 ~ QFT*Time + Gender*Time + (Time| ID), data = groupB2, family = Gamma(link = "log"))

n1B = length(qft_pca_set1B)
v1.1 = varB[8]
v1.2 = varB[13]
v1.3 = varB[14]
v1.4 = varB[17]
v1.5 = varB[18]

# Cluster 2 models

BM_C2.1 = glmmTMB(O10 ~ QFT*Time + Gender*Time + (1| ID), data = groupB2, family = tweedie(link = "log"))
BS_C2.1 = summary(BM_C2.1)

BM_C2.2 = glmmTMB(O11 ~ QFT*Time + Gender*Time + (1| ID), data = groupB2, family = poisson(link = "log"))
BS_C2.2 = summary(BM_C2.2)

n2B = length(qft_pca_set2B)

v2.1 = varB[10]
v2.2 = varB[11]


```

Create a contrast matrix for the predetermined pairwise comparisons.

```{r}

# Extract combinations of the levels

combinations = data.frame(emmeans(BM_C1.1, ~ QFT * Time))
combination_names = paste(combinations$QFT, combinations$Time, sep = "_")

# Define the list of contrasts

contrast_list = list(
  
  # Comparisons within Negative
  
  "Negative_T2_vs_T1" = setNames(c(1, 0, -1, 0), combination_names),
  
  # Comparisons within Positive
  
  "Positive_T2_vs_T1" = setNames(c(0, 1, 0, -1), combination_names),
  
  # Comparisons between Negative and Positive
  
  "T2_Negative_vs_Positive" = setNames(c(1, -1, 0, 0), combination_names),
  "T1_Negative_vs_Positive" = setNames(c(0, 0, 1, -1), combination_names)
)

contrast_list
```
Estimate and apply corrections for Cluster 1. No significant differences.
```{r}

emmC1.1 = emmeans(BM_C1.1, ~ QFT * Time)
emmC1.2 = emmeans(BM_C1.2, ~ QFT * Time)
emmC1.3 = emmeans(BM_C1.3, ~ QFT * Time)
emmC1.4 = emmeans(BM_C1.4, ~ QFT * Time)
emmC1.5 = emmeans(BM_C1.5, ~ QFT * Time)

# Apply custom contrasts
contrastsC1.1 = data.frame(contrast(emmC1.1, method = contrast_list, adjust = "none"))
contrastsC1.2 = data.frame(contrast(emmC1.2, method = contrast_list, adjust = "none"))
contrastsC1.3 = data.frame(contrast(emmC1.3, method = contrast_list, adjust = "none"))
contrastsC1.4 = data.frame(contrast(emmC1.4, method = contrast_list, adjust = "none"))
contrastsC1.5 = data.frame(contrast(emmC1.5, method = contrast_list, adjust = "none"))

contrastsC1.1$Outcome = v1.1
contrastsC1.2$Outcome = v1.2
contrastsC1.3$Outcome = v1.3
contrastsC1.4$Outcome = v1.4
contrastsC1.5$Outcome = v1.5

clusterC1res = rbind(contrastsC1.1, contrastsC1.2, contrastsC1.3, contrastsC1.4, contrastsC1.5)
clusterC1res = clusterC1res %>% arrange(p.value)

clusterC1res$BH = p.adjust(clusterC1res$p.value, method = "BH", n = length(clusterC1res$p.value))
clusterC1res$BY = p.adjust(clusterC1res$p.value, method = "BY", n = length(clusterC1res$p.value))

clusterC1res$expestimate = exp(clusterC1res$estimate)

clusterC1res %>% filter(BH < 0.06) %>% filter(Outcome == v1.1)
clusterC1res %>% filter(BH < 0.06) %>% filter(Outcome == v1.2)
clusterC1res %>% filter(BH < 0.06) %>% filter(Outcome == v1.3)
clusterC1res %>% filter(BH < 0.06) %>% filter(Outcome == v1.4)
clusterC1res %>% filter(BH < 0.06) %>% filter(Outcome == v1.5)

```

Estimate and apply corrections for Cluster 2. No significant differences.
```{r}


emmC2.1 = emmeans(BM_C2.1, ~ QFT * Time)
emmC2.2 = emmeans(BM_C2.2, ~ QFT * Time)

# Apply custom contrasts
contrastsC2.1 = data.frame(contrast(emmC2.1, method = contrast_list, adjust = "none"))
contrastsC2.2 = data.frame(contrast(emmC2.2, method = contrast_list, adjust = "none"))

contrastsC2.1$Outcome = v2.1
contrastsC2.2$Outcome = v2.2


clusterC2res = rbind(contrastsC2.1, contrastsC2.2)
clusterC2res = clusterC2res %>% arrange(p.value)

clusterC2res$BH = p.adjust(clusterC2res$p.value, method = "BH", n = length(clusterC2res$p.value))
clusterC2res$BY = p.adjust(clusterC2res$p.value, method = "BY", n = length(clusterC2res$p.value))

clusterC2res$expestimate = exp(clusterC2res$estimate)

clusterC2res %>% filter(BH < 0.06) %>% filter(Outcome == v2.1)
clusterC2res %>% filter(BH < 0.06) %>% filter(Outcome == v2.2)


```
```{r}

mat3.2A = tmelt_3A[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

mat3.2A = mat3.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

mat3.2A_wide = mat3.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

mat3.2A = as.matrix(mat3.2A_wide[, 2:4], nrow = nrow(mat3.2A_wide), ncol = 3)
row.names(mat3.2A) = mat3.2A_wide$Outcome
dist3.2A = get_dist(mat3.2A, "pearson")

mat3.2B = tmelt_3B[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

mat3.2B = mat3.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

mat3.2B_wide = mat3.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

mat3.2B = as.matrix(mat3.2B_wide[, 2:3], nrow = nrow(mat3.2A_wide), ncol = 2)
row.names(mat3.2B) = mat3.2B_wide$Outcome
dist3.2B = get_dist(mat3.2B, "pearson")
```

```{r}

res3.2.hclustA = as.hclust(agnes(dist3.2A, diss = TRUE, method = "average"))
res3.2.hclustB = as.hclust(agnes(dist3.2B, diss = TRUE, method = "average"))
```

There are effectively 7 groups. Perf+ Ki67+ CD4 is a singleton, but the others require representatives.
```{r}

hcdata3.2A = dendro_data_k(res3.2.hclustA, 7)

p = plot_ggdendro(hcdata3.2A,
                  scale.color = cols,
                   direction   = "rl",
                   expand.y    = 0.2) 
p + ylab("\n Link Height") + geom_hline(yintercept = 0.15, linetype = "solid", size = 1) + theme_bw() +
  theme(axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
        axis.title.y = element_blank(),
        axis.text.x = element_text(size = 10, family = "Arial"),
        axis.text.y = element_text(size = 10, family = "Arial"))
  
hcdata3.2B = dendro_data_k(res3.2.hclustB, 2)

p = plot_ggdendro(hcdata3.2B,
                  scale.color = c("darkblue", "darkgreen"),
                   direction   = "rl",
                   expand.y    = 0.2) 
p + ylab("\n Link Height") + geom_hline(yintercept = 0.15, linetype = "solid", size = 1) + theme_bw() +
  theme(axis.title.x = element_text(size = 12, family = "Arial", face = "bold"),
        axis.title.y = element_blank(),
        axis.text.x = element_text(size = 10, family = "Arial"),
        axis.text.y = element_text(size = 10, family = "Arial"))

```

```{r}

clusters3.2A = cutree(res3.2.hclust, k=7)

# Group 1

names1 = names(clusters3.2A[clusters3.2A == 1])
names2 = names(clusters3.2A[clusters3.2A == 2])
names3 = names(clusters3.2A[clusters3.2A == 3])
names4 = names(clusters3.2A[clusters3.2A == 4])
names5 = names(clusters3.2A[clusters3.2A == 5])
names6 = names(clusters3.2A[clusters3.2A == 6])
names7 = names(clusters3.2A[clusters3.2A == 7])

```

```{r}

mat3.2A = tmelt_3A[, c("Outcome", "Coefficient", "value")]
mat3.2A = mat3.2A %>% filter(Outcome %in% names1)

# Restructure the data frame

pca3.2A = mat3.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca3.2A_wide = pca3.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca3.2A_mat = as.matrix(pca3.2A_wide[, 2:4], nrow = nrow(pca3.2A_wide), ncol = 3)
rownames(pca3.2A_mat) = pca3.2A_wide$Outcome

pca3.2Ares = princomp(pca3.2A_mat, cor = TRUE, scores = TRUE)
summary(pca3.2Ares) # Component 1 should suffice

fviz_eig(pca3.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca3.2Ares, axes = 1, choice = "var")
#fviz_contrib(pca2.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib3.2A.1 = fviz_contrib(pca3.2Ares, axes = 1, choice = "ind")
#contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib3.2A.1$data[which(contrib3.2A.1$data$contrib >= 10), ]
#pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 20), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

fa_pca_set1 = pcnames1

```

```{r}

mat3.2A = tmelt_3A[, c("Outcome", "Coefficient", "value")]
mat3.2A = mat3.2A %>% filter(Outcome %in% names2)

# Restructure the data frame

pca3.2A = mat3.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca3.2A_wide = pca3.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca3.2A_mat = as.matrix(pca3.2A_wide[, 2:4], nrow = nrow(pca3.2A_wide), ncol = 3)
rownames(pca3.2A_mat) = pca3.2A_wide$Outcome

pca3.2Ares = princomp(pca3.2A_mat, cor = TRUE, scores = TRUE)
summary(pca3.2Ares) # Component 1 should suffice

fviz_eig(pca3.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca3.2Ares, axes = 1, choice = "var")
#fviz_contrib(pca2.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib3.2A.1 = fviz_contrib(pca3.2Ares, axes = 1, choice = "ind")
#contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib3.2A.1$data[which(contrib3.2A.1$data$contrib >= 15), ]
#pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 20), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

fa_pca_set2 = pcnames1

```

```{r}

mat3.2A = tmelt_3A[, c("Outcome", "Coefficient", "value")]
mat3.2A = mat3.2A %>% filter(Outcome %in% names3)

# Restructure the data frame

pca3.2A = mat3.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca3.2A_wide = pca3.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca3.2A_mat = as.matrix(pca3.2A_wide[, 2:4], nrow = nrow(pca3.2A_wide), ncol = 3)
rownames(pca3.2A_mat) = pca3.2A_wide$Outcome

pca3.2Ares = princomp(pca3.2A_mat, cor = TRUE, scores = TRUE)
summary(pca3.2Ares) # Component 1 should suffice

fviz_eig(pca3.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca3.2Ares, axes = 1, choice = "var")
fviz_contrib(pca3.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib3.2A.1 = fviz_contrib(pca3.2Ares, axes = 1, choice = "ind")
contrib3.2A.2 = fviz_contrib(pca3.2Ares, axes = 2, choice = "ind")

pc1dat = contrib3.2A.1$data[which(contrib3.2A.1$data$contrib >= 15), ]
pc2dat = contrib3.2A.2$data[which(contrib3.2A.2$data$contrib >= 15), ]

pcnames1 = as.character(unique(c(pc1dat$name, pc2dat$name)))

fa_pca_set3 = pcnames1

```

```{r}

mat3.2A = tmelt_3A[, c("Outcome", "Coefficient", "value")]
mat3.2A = mat3.2A %>% filter(Outcome %in% names5)

# Restructure the data frame

pca3.2A = mat3.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca3.2A_wide = pca3.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca3.2A_mat = as.matrix(pca3.2A_wide[, 2:4], nrow = nrow(pca3.2A_wide), ncol = 3)
rownames(pca3.2A_mat) = pca3.2A_wide$Outcome

pca3.2Ares = princomp(pca3.2A_mat, cor = TRUE, scores = TRUE)
summary(pca3.2Ares) # Component 1 should suffice

fviz_eig(pca3.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca3.2Ares, axes = 1, choice = "var")
#fviz_contrib(pca2.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib3.2A.1 = fviz_contrib(pca3.2Ares, axes = 1, choice = "ind")
#contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib3.2A.1$data[which(contrib3.2A.1$data$contrib >= 20), ]
#pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 10), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

fa_pca_set5 = pcnames1

```

```{r}
faclusters = c(fa_pca_set1, fa_pca_set2, fa_pca_set3, names4, fa_pca_set5, names6, names7)

"Bulk CD4+/% R7+RA-" "Bulk CD8+/% R7-RA-"
```

```{r}

mat4.2A = tmelt_4A[, c("Outcome", "Group", "Coefficient", "value")]

# Restructure the data frame

mat4.2A$OutcomeGroup = paste(mat4.2A$Outcome, mat4.2A$Group)
mat4.2A2 = mat4.2A[, c("OutcomeGroup", "Coefficient", "value")]

mat4.2A2_wide = mat4.2A2 %>%
  pivot_wider(names_from = Coefficient, id_cols = OutcomeGroup, values_from = value)

mat4.2A2 = as.matrix(mat4.2A2_wide[, 2:4], nrow = nrow(mat4.2A2_wide), ncol = 3)
row.names(mat4.2A2) = mat4.2A_wide$OutcomeGroup
dist4.2A = get_dist(mat4.2A2, "pearson")
```


```{r}

res4.2.hclust = as.hclust(agnes(dist4.2A, diss = TRUE, method = "average"))
```

There are effectively 7 groups. Perf+ Ki67+ CD4 is a singleton, but the others require representatives.
```{r}

hcdata4.2 = dendro_data_k(res4.2.hclust, 10)

p = plot_ggdendro(hcdata4.2,
                   direction   = "rl",
                   expand.y    = 0.2) 
p + ylab("Link Height") + geom_hline(yintercept = 0.1) + theme(axis.title.y = element_blank())

```

```{r}

clusters4.2A = cutree(res4.2.hclust, k=10)

# Partial matches to find
matches = unique(datA$Group)

# Function to drop content after finding a partial match
drop_after_match = function(string, matches) {
  # Create a pattern that matches any of the words in 'matches'
  pattern = paste(matches, collapse = "|")
  # Use 'sub()' to drop everything after and including the matched word
  sub(paste0("(.*?)\\s+(", pattern, ").*"), "\\1", string)
}

# Apply the function to the list of strings
pcnames5_split = unique(lapply(pcnames5, drop_after_match, matches))

gender_pca_set = pcnames5_split

# Group 1

names1 = names(clusters4.2A[clusters4.2A == 1])
names1split = unique(lapply(names1, drop_after_match, matches))

names2 = names(clusters4.2A[clusters4.2A == 2])
names2split = unique(lapply(names2, drop_after_match, matches))

names3 = names(clusters4.2A[clusters4.2A == 3])
names3split = unique(lapply(names3, drop_after_match, matches))

names4 = names(clusters4.2A[clusters4.2A == 4])
names4split = unique(lapply(names4, drop_after_match, matches))

names5 = names(clusters4.2A[clusters4.2A == 5])
names5split = unique(lapply(names5, drop_after_match, matches))

names6 = names(clusters4.2A[clusters4.2A == 6])
names6split = unique(lapply(names6, drop_after_match, matches))

names7 = names(clusters4.2A[clusters4.2A == 7])
names7split = unique(lapply(names7, drop_after_match, matches))

names8 = names(clusters4.2A[clusters4.2A == 8])
names8split = unique(lapply(names8, drop_after_match, matches))

names9 = names(clusters4.2A[clusters4.2A == 9])
names9split = unique(lapply(names9, drop_after_match, matches))

names10 = names(clusters4.2A[clusters4.2A == 10])
names10split = unique(lapply(names10, drop_after_match, matches))

```

```{r}

mat4.2A = tmelt_4A[, c("Outcome", "Coefficient", "value")]
mat4.2A = mat4.2A %>% filter(Outcome %in% names1split)

# Restructure the data frame

pca4.2A = mat4.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca4.2A_wide = pca4.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca4.2A_mat = as.matrix(pca4.2A_wide[, 2:4], nrow = nrow(pca4.2A_wide), ncol = 3)
rownames(pca4.2A_mat) = pca4.2A_wide$Outcome

pca4.2Ares = princomp(pca4.2A_mat, cor = TRUE, scores = TRUE)
summary(pca4.2Ares) # Component 1 should suffice

fviz_eig(pca4.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca4.2Ares, axes = 1, choice = "var")
#fviz_contrib(pca2.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib4.2A.1 = fviz_contrib(pca4.2Ares, axes = 1, choice = "ind")
#contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib4.2A.1$data[which(contrib4.2A.1$data$contrib >= 20), ]
#pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 20), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

sex_pca_set1 = pcnames1

```

```{r}

mat4.2A = tmelt_4A[, c("Outcome", "Coefficient", "value")]
mat4.2A = mat4.2A %>% filter(Outcome %in% names2split)

# Restructure the data frame

pca4.2A = mat4.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca4.2A_wide = pca4.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca4.2A_mat = as.matrix(pca4.2A_wide[, 2:4], nrow = nrow(pca4.2A_wide), ncol = 3)
rownames(pca4.2A_mat) = pca4.2A_wide$Outcome

pca4.2Ares = princomp(pca4.2A_mat, cor = TRUE, scores = TRUE)
summary(pca4.2Ares) # Component 1 should suffice

fviz_eig(pca4.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca4.2Ares, axes = 1, choice = "var")
#fviz_contrib(pca2.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib4.2A.1 = fviz_contrib(pca4.2Ares, axes = 1, choice = "ind")
#contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib4.2A.1$data[which(contrib4.2A.1$data$contrib >= 8), ]
#pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 20), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

sex_pca_set2 = pcnames1

```

```{r}

mat4.2A = tmelt_4A[, c("Outcome", "Coefficient", "value")]
mat4.2A = mat4.2A %>% filter(Outcome %in% names3split)

# Restructure the data frame

pca4.2A = mat4.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca4.2A_wide = pca4.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca4.2A_mat = as.matrix(pca4.2A_wide[, 2:4], nrow = nrow(pca4.2A_wide), ncol = 3)
rownames(pca4.2A_mat) = pca4.2A_wide$Outcome

pca4.2Ares = princomp(pca4.2A_mat, cor = TRUE, scores = TRUE)
summary(pca4.2Ares) # Component 1 should suffice

fviz_eig(pca4.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca4.2Ares, axes = 1, choice = "var")
#fviz_contrib(pca3.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib4.2A.1 = fviz_contrib(pca4.2Ares, axes = 1, choice = "ind")
#contrib3.2A.2 = fviz_contrib(pca3.2Ares, axes = 2, choice = "ind")

pc1dat = contrib4.2A.1$data[which(contrib4.2A.1$data$contrib >= 10), ]
#pc2dat = contrib3.2A.2$data[which(contrib3.2A.2$data$contrib >= 15), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

sex_pca_set3 = pcnames1

```

```{r}

mat4.2A = tmelt_4A[, c("Outcome", "Coefficient", "value")]
mat4.2A = mat4.2A %>% filter(Outcome %in% names4split)

# Restructure the data frame

pca4.2A = mat4.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca4.2A_wide = pca4.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca4.2A_mat = as.matrix(pca4.2A_wide[, 2:4], nrow = nrow(pca4.2A_wide), ncol = 3)
rownames(pca4.2A_mat) = pca4.2A_wide$Outcome

pca4.2Ares = princomp(pca4.2A_mat, cor = TRUE, scores = TRUE)
summary(pca4.2Ares) # Component 1 should suffice

fviz_eig(pca4.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca4.2Ares, axes = 1, choice = "var")
#fviz_contrib(pca2.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib4.2A.1 = fviz_contrib(pca4.2Ares, axes = 1, choice = "ind")
#contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib4.2A.1$data[which(contrib4.2A.1$data$contrib >= 20), ]
#pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 10), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

sex_pca_set4 = pcnames1

```

```{r}

mat4.2A = tmelt_4A[, c("Outcome", "Coefficient", "value")]
mat4.2A = mat4.2A %>% filter(Outcome %in% names5split)

# Restructure the data frame

pca4.2A = mat4.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca4.2A_wide = pca4.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca4.2A_mat = as.matrix(pca4.2A_wide[, 2:4], nrow = nrow(pca4.2A_wide), ncol = 3)
rownames(pca4.2A_mat) = pca4.2A_wide$Outcome

pca4.2Ares = princomp(pca4.2A_mat, cor = TRUE, scores = TRUE)
summary(pca4.2Ares) # Component 1 should suffice

fviz_eig(pca4.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca4.2Ares, axes = 1, choice = "var")
#fviz_contrib(pca2.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib4.2A.1 = fviz_contrib(pca4.2Ares, axes = 1, choice = "ind")
#contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib4.2A.1$data[which(contrib4.2A.1$data$contrib >= 40), ]
#pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 10), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

sex_pca_set5 = pcnames1

```

```{r}

mat4.2A = tmelt_4A[, c("Outcome", "Coefficient", "value")]
mat4.2A = mat4.2A %>% filter(Outcome %in% names6split)

# Restructure the data frame

pca4.2A = mat4.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca4.2A_wide = pca4.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca4.2A_mat = as.matrix(pca4.2A_wide[, 2:4], nrow = nrow(pca4.2A_wide), ncol = 3)
rownames(pca4.2A_mat) = pca4.2A_wide$Outcome

pca4.2Ares = princomp(pca4.2A_mat, cor = TRUE, scores = TRUE)
summary(pca4.2Ares) # Component 1 should suffice

fviz_eig(pca4.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca4.2Ares, axes = 1, choice = "var")
fviz_contrib(pca4.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib4.2A.1 = fviz_contrib(pca4.2Ares, axes = 1, choice = "ind")
contrib4.2A.2 = fviz_contrib(pca4.2Ares, axes = 2, choice = "ind")

pc1dat = contrib4.2A.1$data[which(contrib4.2A.1$data$contrib >= 20), ]
pc2dat = contrib4.2A.2$data[which(contrib4.2A.2$data$contrib >= 20), ]

pcnames1 = as.character(unique(c(pc1dat$name, pc2dat$name)))

sex_pca_set6 = pcnames1

```

```{r}

mat4.2A = tmelt_4A[, c("Outcome", "Coefficient", "value")]
mat4.2A = mat4.2A %>% filter(Outcome %in% names7split)

# Restructure the data frame

pca4.2A = mat4.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca4.2A_wide = pca4.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca4.2A_mat = as.matrix(pca4.2A_wide[, 2:4], nrow = nrow(pca4.2A_wide), ncol = 3)
rownames(pca4.2A_mat) = pca4.2A_wide$Outcome

pca4.2Ares = princomp(pca4.2A_mat, cor = TRUE, scores = TRUE)
summary(pca4.2Ares) # Component 1 should suffice

fviz_eig(pca4.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca4.2Ares, axes = 1, choice = "var")
#fviz_contrib(pca4.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib4.2A.1 = fviz_contrib(pca4.2Ares, axes = 1, choice = "ind")
#contrib4.2A.2 = fviz_contrib(pca4.2Ares, axes = 2, choice = "ind")

pc1dat = contrib4.2A.1$data[which(contrib4.2A.1$data$contrib >= 20), ]
#pc2dat = contrib4.2A.2$data[which(contrib4.2A.2$data$contrib >= 20), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

sex_pca_set7 = pcnames1

```

```{r}

mat4.2A = tmelt_4A[, c("Outcome", "Coefficient", "value")]
mat4.2A = mat4.2A %>% filter(Outcome %in% names8split)

# Restructure the data frame

pca4.2A = mat4.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca4.2A_wide = pca4.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca4.2A_mat = as.matrix(pca4.2A_wide[, 2:4], nrow = nrow(pca4.2A_wide), ncol = 3)
rownames(pca4.2A_mat) = pca4.2A_wide$Outcome

pca4.2Ares = princomp(pca4.2A_mat, cor = TRUE, scores = TRUE)
summary(pca4.2Ares) # Component 1 should suffice

fviz_eig(pca4.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca4.2Ares, axes = 1, choice = "var")
#fviz_contrib(pca2.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib4.2A.1 = fviz_contrib(pca4.2Ares, axes = 1, choice = "ind")
#contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib4.2A.1$data[which(contrib4.2A.1$data$contrib >= 20), ]
#pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 10), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

sex_pca_set8 = pcnames1

```

```{r}

mat4.2A = tmelt_4A[, c("Outcome", "Coefficient", "value")]
mat4.2A = mat4.2A %>% filter(Outcome %in% names9split)

# Restructure the data frame

pca4.2A = mat4.2A %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca4.2A_wide = pca4.2A %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca4.2A_mat = as.matrix(pca4.2A_wide[, 2:4], nrow = nrow(pca4.2A_wide), ncol = 3)
rownames(pca4.2A_mat) = pca4.2A_wide$Outcome

pca4.2Ares = princomp(pca4.2A_mat, cor = TRUE, scores = TRUE)
summary(pca4.2Ares) # Component 1 should suffice

fviz_eig(pca4.2Ares, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1 & 2

```

```{r}
fviz_contrib(pca4.2Ares, axes = 1, choice = "var")
#fviz_contrib(pca2.2Ares, axes = 2, choice = "var")
```
The names of these 2 immune outcomes are printed below.
```{r}
contrib4.2A.1 = fviz_contrib(pca4.2Ares, axes = 1, choice = "ind")
#contrib2.2A.2 = fviz_contrib(pca2.2Ares, axes = 2, choice = "ind")

pc1dat = contrib4.2A.1$data[which(contrib4.2A.1$data$contrib >= 30), ]
#pc2dat = contrib2.2A.2$data[which(contrib2.2A.2$data$contrib >= 10), ]

pcnames1 = as.character(unique(c(pc1dat$name)))

sex_pca_set9 = pcnames1

```

```{r}
sexclusters = c(sex_pca_set1, sex_pca_set2, sex_pca_set3, sex_pca_set4, sex_pca_set5, sex_pca_set6, sex_pca_set7, sex_pca_set8, sex_pca_set9, names10split)
```

```{r}

# Group A set comparison

Aset_list = list(MVA85A = mvaclusters, QFT = qftclusters, FA = faclusters, Sex = sexclusters)

Aresult = sapply(allA, function(x) {
  sapply(Aset_list, function(vec) as.numeric(x %in% vec))
})

Aset_res = t(Aresult)
Amelt = melt(Aset_res)
colnames(Amelt) = c("Outcome", "Variable", "Indicator")
Amelt$Indicator = as.logical(Amelt$Indicator)

library(extrafont)
loadfonts(device = "win")  # For Windows users
windowsFonts()

ggplot(Amelt, aes(x = Variable, y = reorder(Outcome, Indicator), fill = Indicator)) +
  geom_tile(color = "black") + theme_minimal() +
  theme(axis.text.y = element_text(size=9, family = "TT Arial"),
        axis.text.x = element_text(size=10, angle = 0, family = "TT Arial", face = "bold"),
        axis.title.y = element_blank(), axis.title.x = element_blank(), legend.position = "none") +
scale_fill_manual(name = "Selected", breaks = c("FALSE", "TRUE"), values = c("lightgrey", "darkcyan"))

```


```{r}

mat1.2B = tmelt_1B[, c("Outcome", "Coefficient", "value")]

# Restructure the data frame

mat1.2B = mat1.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

mat1.2B_wide = mat1.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

mat1.2B = as.matrix(mat1.2B_wide[, 2:3], nrow = nrow(mat1.2A_wide), ncol = 2)
row.names(mat1.2B) = mat1.2B_wide$Outcome
dist1.2B = get_dist(mat1.2B, "pearson")

```

```{r}

res1.2.hclustB = as.hclust(agnes(dist1.2B, diss = TRUE, method = "average"))
```

There are 2 groups.
```{r}

hcdata1.2B = dendro_data_k(res1.2.hclustB, 2)

p = plot_ggdendroh(hcdata1.2B,
                   direction   = "rl",
                   expand.y    = 0.2) 
p + ylab("\n Link Height") + geom_hline(yintercept = 0.15, linetype = "solid", size = 1) + theme_minimal() + theme(axis.title.y = element_blank())


```

```{r}

clusters1.2B = cutree(res1.2.hclustB, k=2)

# Group 1

names1 = names(clusters1.2B[clusters1.2B == 1])
names2 = names(clusters1.2B[clusters1.2B == 2])


```

CD4+ any is the most similar to all other objects in the cluster.

```{r}

mat1.2B = tmelt_1B[, c("Outcome", "Coefficient", "value")]
mat1.2B = mat1.2B %>% filter(Outcome %in% names1)

# Restructure the data frame

pca1.2B = mat1.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca1.2B_wide = pca1.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca1.2B_mat = as.matrix(pca1.2B_wide[, 2:3], nrow = nrow(pca1.2B_wide), ncol = 2)
rownames(pca1.2B_mat) = pca1.2B_wide$Outcome

pca1.2Bres = princomp(pca1.2B_mat, cor = TRUE, scores = TRUE)
summary(pca1.2Bres) # Component 1 should suffice

fviz_eig(pca1.2Bres, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1

```

```{r}

mat1.2B = tmelt_1B[, c("Outcome", "Coefficient", "value")]
mat1.2B = mat1.2B %>% filter(Outcome %in% names2)

# Restructure the data frame

pca1.2B = mat1.2B %>%
  distinct(Outcome, Coefficient, .keep_all = TRUE)

pca1.2B_wide = pca1.2B %>%
  pivot_wider(names_from = Coefficient, id_cols = Outcome, values_from = value)

pca1.2B_mat = as.matrix(pca1.2B_wide[, 2:3], nrow = nrow(pca1.2B_wide), ncol = 2)
rownames(pca1.2B_mat) = pca1.2B_wide$Outcome

pca1.2Bres = princomp(pca1.2B_mat, cor = TRUE, scores = TRUE)
summary(pca1.2Bres) # Component 1 should suffice

fviz_eig(pca1.2Bres, xlab = "\n Number of Principal Components", ylab = "Variance Explained (%)\n", main = "", ylim = c(0, 100))

# Look at component 1

```
```{r}

fviz_contrib(pca1.2Bres, axes = 1, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

fviz_contrib(pca1.2Bres, axes = 2, choice = "ind", fill = "darkgrey", color = "black", top = 10) +
  labs(y = element_text("Contributions(%)\n")) +
  theme_minimal() +
  theme(title = element_blank(),
        axis.title.y = element_text(size = 12, face = "bold"),
        axis.title.x = element_blank(),
        axis.text.x = element_text(size = 10, angle = 45, vjust = 1, hjust = 1),
        axis.text.y = element_text(size = 10))

```
